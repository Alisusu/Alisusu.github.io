<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="flyfish&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="flyfish&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flyfish&#39;s blog">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>flyfish's blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"><i class="fa fa-bookmark-o"></i>&nbsp;flyfish's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/have-fun.html" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>元素周期表</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/C语言实现可变参数函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/C语言实现可变参数函数/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">C语言实现可变参数函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 15:55:16 / 修改时间：15:58:34" itemprop="dateCreated datePublished" datetime="2019-02-28T15:55:16+08:00">2019-02-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C语言/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文转载自<a href="http://blog.sina.com.cn/s/blog_3fe961ae0100nf1l.html" target="_blank" rel="noopener">C语言实现可变参数函数</a></strong></p>
<h3 id="C语言实现可变参数函数"><a href="#C语言实现可变参数函数" class="headerlink" title="C语言实现可变参数函数"></a>C语言实现可变参数函数</h3><pre><code>C语言中可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分。
C语言的可变参数函数主要要用到了一个类型va_list和三个宏——va_start、va_arg和va_end。
C语言的可变参数函数必须以某种方式提供参数的个数。

我们可以声明一个类型为va_list的变量，与这几个宏配合使用，访问参数的值。这个变量通过调用va_start来初始化。
它的第1个参数是va_list变量的名字，
第2个参数是省略号前最后一个有名字的参数。
初始化过程把var_arg变量设置为指向可变参数部分的第一个参数。
为了访问参数，需要使用va_arg，这个宏接受两个参数：va_list变量和参数列表中下一个参数的类型。
va_arg返回这个参数的值，并使var_arg指向下一个可变参数。
需要注意的是，可变参数必须从头到尾按照顺序访问，不可以一开始就访问参数列表中间的参数。
当访问完毕最后一个可变参数之后，需要调用va_end。
给一段示例代码：
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数至少需要一个确定的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> n_values,...)</span></span>&#123;</span><br><span class="line">    va_list var_arg;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">float</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化，准备访问可变参数，它的第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数。</span></span><br><span class="line">    va_start(var_arg,n_values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取各个参数</span></span><br><span class="line">    <span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;n_values;count++)&#123;</span><br><span class="line">        sum+=va_arg(var_arg,<span class="keyword">int</span>);        </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成</span></span><br><span class="line">    va_end(var_arg);</span><br><span class="line">    <span class="keyword">return</span> sum/n_values; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,average(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/关于__attribute__机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/关于__attribute__机制/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">关于__attribute__机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 15:26:12 / 修改时间：15:37:02" itemprop="dateCreated datePublished" datetime="2019-02-28T15:26:12+08:00">2019-02-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C语言/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="attribute-机制"><a href="#attribute-机制" class="headerlink" title="__attribute__机制"></a>__attribute__机制</h2><p><strong>本文转载自:<a href="http://rungame.me/blog/2016/09/21/attribute-syntax/" target="_blank" rel="noopener">GNU C 中的__attribute__机制</a></strong></p>
<pre><code>__attribute__ 是 GCC 提供的一种语法,可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作。

__attribute__ 的语法格式为: __attribute__ ((attribute-list)) , 
attribute-list 是指令集 , __attribute__ 出现在函数、变量和类型声明的 “;” 前。

__attribute__ 有三类,分别为
    1. 函数属性(Function Attribute) 
    2. 变量属性(Variable Attribute) 
    3. 类型属性(Type Attribute)
</code></pre><h3 id="一-函数属性"><a href="#一-函数属性" class="headerlink" title="一. 函数属性"></a>一. 函数属性</h3><h4 id="1-format-archetype-string-index-first-to-check"><a href="#1-format-archetype-string-index-first-to-check" class="headerlink" title="1. format (archetype, string-index, first-to-check)"></a>1. format (archetype, string-index, first-to-check)</h4><pre><code>format 属性通过指定 printf, scanf, strftime 或 strfmon 等方法来检测函数的参数是否同样适用于这些指定的格式化字符串方法
,如果不适用,编译器在编译时的就会发出警告,从而发现错误。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">my_printf</span> <span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">char</span> *my_format, ...)</span> __<span class="title">attribute__</span> <span class="params">((format (<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_printf(<span class="number">0</span>, <span class="string">"age = %d\n"</span>,<span class="number">17</span>);</span><br><span class="line">    my_printf(<span class="number">0</span>, <span class="string">"age = %d\n"</span>,<span class="string">"17"</span>);</span><br><span class="line">    my_printf(<span class="number">0</span>, <span class="string">"age = %d name = %s\n"</span>,<span class="number">17</span>,<span class="string">"sbxfc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>上面示例中, format 属性的第一个参数指定了一个 printf 方法,
第二个参数 string-index 表示函数 my_printf 里格式化参数是总参数的第几个,这里我们的格式化参数 my_format 是第2个参数,
format 属性的第三个参数表示,参数集合 (…) 从函数 my_printf 的第几个参数开始出现。

如无意外,上述示例在 gcc 编译时会提示以下警告信息:
去掉__attribute__属性,该示例则不会提示错误,但运行时会出错。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c main.c</span><br><span class="line">main.c:12:31: warning: format specifies <span class="built_in">type</span> <span class="string">'int'</span> but the argument has <span class="built_in">type</span></span><br><span class="line">  <span class="string">'char *'</span> [-Wformat]</span><br><span class="line">my_printf(0, <span class="string">"age = %d\n"</span>,<span class="string">"17"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-noreturn"><a href="#2-noreturn" class="headerlink" title="2. noreturn"></a>2. noreturn</h4><pre><code>noreturn 属性表示其指定的函数没有返回值,当编译器执行到这时,要面对现实,不要大惊小怪(~慌忙报错~)。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="comment">/*__attribute__((noreturn))*/</span> onExit();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onExit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">        onExit();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用gcc -c -Wall test.c编译</span></span><br></pre></td></tr></table></figure>
<h4 id="3-deprecated"><a href="#3-deprecated" class="headerlink" title="3. deprecated"></a>3. deprecated</h4><pre><code>deprecated 属性可以用来标识一个预计将会被弃用的函数,如果开发者使用该函数,编译时就会发出警告,
并提示出错的行数。警告信息只会在开发者调用该函数时才会提示,
deprecated 也可以用于变量和类型。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">old_fn</span> <span class="params">()</span> __<span class="title">attribute__</span> <span class="params">((deprecated))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">old_fn</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*fn_ptr)() = old_fn;</span><br></pre></td></tr></table></figure>
<pre><code>在上面示例中,只会在第3行提出警告:
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.c:7:19: warning: <span class="string">'old_fn'</span> is deprecated [-Wdeprecated-declarations]</span><br><span class="line">int (*fn_ptr)() = old_fn;</span><br><span class="line">                    ^</span><br><span class="line">main.c:6:5: note: <span class="string">'old_fn'</span> has been explicitly marked deprecated here</span><br><span class="line">int old_fn ();</span><br></pre></td></tr></table></figure>
<h4 id="4-constructor-amp-destructor"><a href="#4-constructor-amp-destructor" class="headerlink" title="4. constructor &amp; destructor"></a>4. constructor &amp; destructor</h4><pre><code>设置 constructor 属性可以使函数在 main 方法之前执行,而设置 destructor 可以使函数在 main 方法之后执行。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before_func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"before \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">after_func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"after \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main func \n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>constructor 、 destructor 函数也可以设置执行的优先级:
__attribute__((constructor(PRIORITY)))
__attribute__((destructor(PRIORITY)))
</code></pre><h3 id="二-变量属性"><a href="#二-变量属性" class="headerlink" title="二. 变量属性"></a>二. 变量属性</h3><h4 id="1-aligned-alignment"><a href="#1-aligned-alignment" class="headerlink" title="1. aligned (alignment)"></a>1. aligned (alignment)</h4><pre><code>aligned 属性让其指定的变量或结构体成员按 alignment 字节大小对齐。
如果其中对齐长度有长度大于 alignment的,则按照最大对齐长度来对齐。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的对齐值为8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> x[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s0 = <span class="keyword">sizeof</span>(struct foo);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s0 = %d\n"</span>,s0);<span class="comment">//print s0 = 16</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-packed"><a href="#2-packed" class="headerlink" title="2. packed"></a>2. packed</h4><pre><code>packed 属性用于设置变量或结构体成员以最小的对齐方式对齐。
在下面的结构体中,由于 x 已经使用 packed 进行对齐,所以此时结构体以 a 的size来对齐:
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> x[<span class="number">2</span>] __attribute__ ((packed));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s0 = <span class="keyword">sizeof</span>(struct foo);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s0 = %d\n"</span>,s0);<span class="comment">//print s0 = 9</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-类型属性"><a href="#三-类型属性" class="headerlink" title="三. 类型属性"></a>三. 类型属性</h3><h4 id="1-packed"><a href="#1-packed" class="headerlink" title="1. packed"></a>1. packed</h4><pre><code>如果 packed 属性用在 struct 或 union 上,表示该结构的成员变量按照紧凑模式对齐,
即以变量的实际占用字节对齐,不用编译器进行优化对齐。如果用在 enum 上,则表示使用最小的整数来存储枚举类型。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_unpacked_struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">my_packed_struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   <span class="keyword">int</span>  i;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">my_unpacked_struct</span> <span class="title">s</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s0 = <span class="keyword">sizeof</span>(struct my_unpacked_struct);</span><br><span class="line">  <span class="keyword">int</span> s1 = <span class="keyword">sizeof</span>(struct my_packed_struct);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s0 = %d,s1 = %d\n"</span>,s0,s1);<span class="comment">//print s0 = 8,s1 = 13</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/APUE-阅读笔记-第八章-进程控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/APUE-阅读笔记-第八章-进程控制/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第八章 进程控制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 10:38:47 / 修改时间：10:47:43" itemprop="dateCreated datePublished" datetime="2019-02-28T10:38:47+08:00">2019-02-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="APUE-第八章-进程控制"><a href="#APUE-第八章-进程控制" class="headerlink" title="APUE 第八章 进程控制"></a>APUE 第八章 进程控制</h2><h3 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h3><pre><code>本章内容:
    1. 创建新进程, 执行程序和进程终止
    2. 说明进程属性的各种ID-实际,有效和保存的用户ID和组ID.
    3. 如何受到进程控制原语的影响
    4. 解释器文件和system函数
</code></pre><h3 id="8-2-进程标识"><a href="#8-2-进程标识" class="headerlink" title="8.2 进程标识"></a>8.2 进程标识</h3><pre><code>每个进程都有一个非负整型表示的唯一进程ID. 
但同时也是可以服用的, 当进程终止后, 其进程ID就成为服用的候选者, 采用延迟复用算法
ID为0 的进程通常是调度进程, 被称为交换进程
ID为1 的进程通常是init进程, 在自举结束时由内核调用, 负责启动一个UNIX系统. 是一个普通用户进程, 但是由超级用户特权运行.ssh
在某些UNIX系统的虚拟存储器实现中, 进程ID2是页守护进程, 此进程负责支持虚拟存储器系统.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">()</span></span>; <span class="comment">// 返回进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">()</span></span>; <span class="comment">// 返回父进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>; <span class="comment">// 返回进程的用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">// 返回进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>; <span class="comment">// 返回进程的组ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>; <span class="comment">// 返回进程的有效组ID</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-函数fork"><a href="#8-3-函数fork" class="headerlink" title="8.3 函数fork"></a>8.3 函数fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>由函数fork创建的新进程被称为子进程. fork函数被调用一次, 但是返回两次.
两次返回的区别是子进程的返回值是0, 而父进程的返回值则是子进程的进程ID. 
子进程和父进程继续执行fork调用之后的指令, 子进程是父进程的副本. 共享正文段, 但是并不共享堆栈和数据空间
</code></pre><p><strong>写时复制</strong></p>
<pre><code>父进程的数据段, 堆栈由子进程和父进程共享, 但此时内核将他们的访问权限改为只读. 如果父进程和子进程中的任一个试图修改这个区域, 则内核只为修改区域的那块内存制作一个副本. 
</code></pre><p><strong>文件共享</strong></p>
<pre><code>fork的一个特征是父进程的所有打开的文件描述符都被复制到子进程中. 就好像执行了dup函数. 
重要的是, 子进程和父进程共享同一个文件偏移量. 
</code></pre><p><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./文件共享.png" alt="Alt text"></p>
<p><strong>其他继承</strong></p>
<pre><code>1. 实际用户ID, 实际组ID, 有效用户ID, 有效组ID
2. 附属组ID
3. 进程组ID
4. 会话ID
5. 控制终端
6. 设置用户ID标志和设置组ID标志
7. 当前工作目录
8. 根目录
9. 文件创建屏蔽字
10. 信号屏蔽和安排
11. 对任一打开文件描述符执行时关闭标志
12. 环境
13. 连接的共享存储段
14. 存储映像
15. 资源限制
</code></pre><p><strong>子进程和父进程的区别</strong></p>
<pre><code>1. fork返回值不同
2. 进程ID不同, 父进程ID不同
3. 子进程的tms_utime,tms_stime,tms_cutime和tms_ustime的值被设置为0
4. 子进程不继承父进程设置的文件锁
5. 子进程的未处理闹钟被清除
6. 子进程的未处理信号集被设置为空集
</code></pre><h3 id="8-4-函数vfork"><a href="#8-4-函数vfork" class="headerlink" title="8.4 函数vfork"></a>8.4 函数vfork</h3><pre><code>vfork函数用于创建一个新进程, 而该新进程的目的是exec一个新的程序. 
但是并不将父进程的地址空间完全复制到子进程中., 但是在子进程调用用exec或者 exit之前,
在父进程的空间中运行. 但是如果修改数据, 进行函数调用,
或者没有调用exec或者exit就返回就可能带来未知的结果
vfork保证子进程先运行. 调用exit或者exec之后, 父进程 才可能被调度运行.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globval = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before vfork\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pid = vfork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"vfork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        globval++;</span><br><span class="line">        var++;</span><br><span class="line">        _exit(<span class="number">0</span>);  <span class="comment">// 此处如果调用exit, 结果是不确定的.因为依赖于标准IO库的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %ld, glob = %d, var = %d\n"</span>, (<span class="keyword">long</span>)getpid(), globval, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-函数exit"><a href="#8-5-函数exit" class="headerlink" title="8.5 函数exit"></a>8.5 函数exit</h3><p><strong>正常终止</strong></p>
<pre><code>1. 调用return 0, 相当于调用exit(0) 
2. 调用exit 函数, 其操作包括调用各终止处理程序(atexit), 关闭所有标准IO流.
3. 调用_exit或者_Exit函数, 目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法. 在UNIX中,_exit和_Exit是同义的, 并不冲洗标准IO流
4. 进程的最后一个线程在其启动例程中执行return语句, 但是该线程的返回值不作为进程的返回值.
5. 进程的最后一个线程调用pehread_exit函数, 这种情况下,进程的终止状态总是0. 
</code></pre><p><strong>异常终止</strong></p>
<pre><code>1. 调用abort, 产生SIGABRT信号, 这是下一种异常终止的一种特例
2. 接收到一个信号. 信号可以由进程自身, 其他进程或者内核产生.
3. 最后一个线程对取消请求做出响应. 默认情况下,取消以延迟方式发生: 一个线程要求取消另一个线程, 若干时间后, 目标线程终止.

不管进程如何终止, 都会执行内核中的同一段代码, 这段代码为相应进程关闭所有打开的文件描述符. 释放它所使用的存储器. 
</code></pre><p><strong>终止通知父进程</strong></p>
<pre><code>对于三个终止函数, 将其退出状态作为参数传递给函数. 异常终止时, 内核产生一个指示其异常终止原因的终止状态.
在任意一种情况下, 该终止进程的父进程都能用wait或者waitpid函数取得其终止状态.
如果子进程`完全消失`了, 那么父进程是无法获取终止状态的.
实际上内核为每个终止进程保存了一定量的信息, 所以当终止进程的父进程调用wait或者waitpid时, 可以得到这些信息. 
这些信息至少包括进程ID, 该进程的终止状态,以及该进程使用的CPU时间总量.
</code></pre><p><strong>僵死进程</strong></p>
<pre><code>一个已经终止, 但是其父进程尚未对其进行善后处理的进程被称为僵死进程
善后处理包括: 获取终止子进程的有关信息, 释放它的资源
</code></pre><p><strong>父进程终止</strong></p>
<pre><code>对于父进程已经终止的所有进程, 他们的父进程都改变为init进程. 我们称被init进程收养
当一个进程终止是, 内核逐个检查所有的活动进程, 以判断它是否是要终止进程的子进程, 如果是,该 进程的父进程ID就改为1
</code></pre><h3 id="8-6-函数wait和waitpid"><a href="#8-6-函数wait和waitpid" class="headerlink" title="8.6 函数wait和waitpid"></a>8.6 函数wait和waitpid</h3><pre><code>当一个进程正常或者异常终止时, 内核就向其父进程发送SIGCHLD信号.
因为子进程终止是一个异步事件, 所以这总信号也是内核向父进程发的异步通知. 
父进程可以选择忽略该信号, 或者提供一个该信号发生时即被调用执行的函数.
调用wait或者waitpid会发生什么: 
1. 如果其所有子进程都还在运行, 则阻塞
2. 如果一个子进程已终止, 正等待父进程获取其终止装填, 则取得该子进程的终止状态立即返回
3. 如果它没有任何子进程, 则立即出错返回
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>statloc 是一个整型指针, 如果说statloc不是一个空指针,
则终止进程的终止状态就存放在它所指向的单元内. 
</code></pre><p><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./wait.png" alt="Alt text"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"normal termination, exit status = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abnormal termination, signal num = %d %s\n"</span>, WTERMSIG(status),</span><br><span class="line">#ifdef WCOREDUMP</span><br><span class="line">               WCOREDUMP(status) ? <span class="string">"(core file generated)"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">               <span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child stoped, signal number = %d\n"</span>, WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait(&amp;status) != pid) &#123;</span><br><span class="line">        err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_exit(status);</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait(&amp;status) != pid) &#123;</span><br><span class="line">        err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_exit(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        status /= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait(&amp;status) != pid) &#123;</span><br><span class="line">        err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_exit(status);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>waitpid</strong></p>
<pre><code>pid==-1 等待任一个子进程
pi &gt; 0 等待进程ID和pid相等的子进程
pid==0 等待组ID等于调用进程组ID的任一子进程
pid&lt; -1 等待组ID等于pid绝对值的任一进程

option 是我们进一步控制waitpid的操作, 此参数或者是0, 或者是下图常量按位或运算的结果
</code></pre><p><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./wait_option.png" alt="Alt text"></p>
<h3 id="8-7-函数waitpid"><a href="#8-7-函数waitpid" class="headerlink" title="8.7 函数waitpid"></a>8.7 函数waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>waitid 允许一个进程指定要等待的子进程. 
但它使用两个独立的参数标识要等待的子进程所属的类型,而不是将此与进程ID或者进程组ID组合成一个参数. 
id参数的作用于idtype的值有关, 该函数支持的IDtype类型的值如下
</code></pre><p><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./waitid.png" alt="Alt text"></p>
<pre><code>option参数是下图各标志的按位或运算.
</code></pre><p><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./waitid_option.png" alt="Alt text"></p>
<pre><code>WCONTINUED, WEXITED或者WSTOPPED三个常量之一必须在options参数中指定.
info参数是指向siginfo结构的指针, 该结构包含了造成子进程状态改变有关信号的详细信息
</code></pre><h3 id="8-8-函数wait3或者函数wait4"><a href="#8-8-函数wait3或者函数wait4" class="headerlink" title="8.8 函数wait3或者函数wait4"></a>8.8 函数wait3或者函数wait4</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>比wait和waitpid的功能多一个, 这与附加参数有关. 
该附加参数允许内核返回由终止进程以及其所有子进程使用的资源概况
资源概况包括: 用户CPU时间总量, 系统CPU时间总量, 缺页次数, 接收到信号的次数等. 
具体看 `man getrusage`
</code></pre><h3 id="8-9-竞争条件"><a href="#8-9-竞争条件" class="headerlink" title="8.9 竞争条件"></a>8.9 竞争条件</h3><pre><code>当多个进程都企图对共享数据进行某种处理, 而最后的结果又取决于进程运行的顺利时, 我们就认为发生了竞争条件. 
如果子进程需要等待父进程结束, 可以使用以下方法
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getpid() != <span class="number">1</span>)&#123; <span class="comment">// 父进程结束, 子进程的父进程变为init进程</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>也可以使用信号机制/进程间通信
</code></pre><h3 id="8-10-函数exec"><a href="#8-10-函数exec" class="headerlink" title="8.10 函数exec"></a>8.10 函数exec</h3><pre><code>8.3节提到的fork函数创建新的子进程后, 子进程往往要调用一种exec函数一遍执行另一个程序. 
当进程调用一种exec函数, 该进程执行的程序完全替换为新程序, 而新程序则从其main函数开始执行. 
exec并不创建新进程, 所有前后的进程ID并未改变. 
有7个不用的exec函数可以供使用. 
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, , <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, .. )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>第一个区别</strong></p>
<pre><code>当指定filename作为参数时: 
1. 如果filename中包含/ , 则就将其视为路径名
2. 否则就按PATH环境变量, 在它指定的各目录中搜寻可执行文件

如果execlp和execvp使用路径前缀中的一个找到了一个可执行文件,
但是该文件不是由连接编辑器产生的机器可执行文件, 则就认为该文件是一个shell脚本.
于是试着调用/bin/sh, 并以filename 作为shell的输入.
</code></pre><hr>
<p><strong>第二个区别</strong></p>
<pre><code>参数表的传递, l表示列表, v表示vector. 
函数execl,execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数. 这种参数表以空指针结尾.
对于另外的四个函数, 则应该先构造出一个指向各参数的指针数组, 然后将该数组地址作为这四个函数的参数
</code></pre><hr>
<p><strong>第三个区别</strong></p>
<pre><code>最后一个区别与想新程序传递环境表相关. 
以e结尾的三个函数, 可以传递一个纸箱环境字符串指针数组的指针. 
其他四个函数则使用调用过程中的environ变量为新程序复制现有的环境.
</code></pre><hr>
<pre><code>前面提及, 在执行exec后, 进程ID没有改变, 但是新程序从调用进程继承了下列属性:
1. 进程ID和父进程ID
2. 实际用户ID和实际组ID
3. 附属组ID
4. 进程组ID
5. 会话ID
6. 控制终端
7. 闹钟尚余留的时间
8. 当前工作目录
9. 根目录
10. 文件模式创建屏蔽字
11. 文件锁
12. 进程信号屏蔽
13. 未处理信号
14. 资源限制
15. nice值
16. tms_utime,tms_stime,tms_cutime和tms_ustime的值
</code></pre><hr>
<p><strong>FD_CLOEXEC标志(3.14)</strong></p>
<pre><code>进程中每个打开文件描述符都有一个执行时关闭标志. 若设置了该标志, 则在执行exec时关闭该描述符, 否则该描述符仍然打开. 
</code></pre><hr>
<p><strong>设置用户/组ID</strong></p>
<pre><code>实际用户ID和实际组ID保持不变. 而有效ID是否改变取决于所执行程序文件的设置用户ID位和设置组ID位是否设置. (参见4.4)
</code></pre><hr>
<p><strong>七个函数之间的关系</strong><br><img src="/2019/02/28/APUE-阅读笔记-第八章-进程控制/./exec.png" alt="Alt text"></p>
<h3 id="8-11-更改用户ID和更改组ID"><a href="#8-11-更改用户ID和更改组ID" class="headerlink" title="8.11 更改用户ID和更改组ID"></a>8.11 更改用户ID和更改组ID</h3><pre><code>一般而言, 在设计应用时, 我们总是试图使用最小特权模型. 程序应当只有为完成给定任务所需的最小特权.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>1. 若进程拥有超级用户权限, 则setuid函数将实际用户ID, 有效用户ID以及保存的设置用户ID设置为uid
2. 若进程没有超级用户特权, 但是uid等于实际用户ID或保存的设置用户ID, 则setuid只将有效用户ID设置为uid, 不更改实际用户ID和保存的设置用户ID
3. 如果上面两个条件都不满足, 则errno设置为EPERM, 并返回-1
</code></pre><p><strong>函数setreuid和setregid</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>其功能是交换有效用户ID和实际用户ID
</code></pre><p><strong>函数seteuid和setegid</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure></p>
<pre><code>类似于setuid和setgid, 但是只更改有效用户ID和有效组ID
</code></pre><h3 id="8-12-解释器文件"><a href="#8-12-解释器文件" class="headerlink" title="8.12 解释器文件"></a>8.12 解释器文件</h3><pre><code>没什么好写的
</code></pre><h3 id="8-13-函数system"><a href="#8-13-函数system" class="headerlink" title="8.13 函数system"></a>8.13 函数system</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>如果cmdstring是一个空指针, 那么返回非0值
system在其实现中调用了fork, exec, waitpid, 因此有三种返回值
1. fork失败或者waitpid返回除了EINTR之外的错误, 则system返回-1, 并且设置errno以指示错误类型.
2. 如果exec失败, 则其返回值如同shell执行了exit(127)一样
3. 否则三个函数都执行成功, 返回值是shell的终止状态(在waitpid中已经说明)
</code></pre><h3 id="8-14-进程会计"><a href="#8-14-进程会计" class="headerlink" title="8.14 进程会计"></a>8.14 进程会计</h3><pre><code>大多数UNIX系统都提供了一个选项️以进行进程会计处理. 启用该选项后,每当进程结束时内核就写一个会计记录.
</code></pre><h3 id="8-15-用户标识"><a href="#8-15-用户标识" class="headerlink" title="8.15 用户标识"></a>8.15 用户标识</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-16-进程调度"><a href="#8-16-进程调度" class="headerlink" title="8.16 进程调度"></a>8.16 进程调度</h3><pre><code>UNIX历史上对于进程提供的只是基于调度优先级的粗粒度的控制. 
调度策略和调度优先级是由内核确定的, 进程可以通过调整nice值选择以更低优先级运行.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>进程使用nice函数获取或者更改它的nice值, 进程只能影响到自己的值, 不能影响到其他的进程.
incr参数被增加到调用进程的nice值上面, 如果incr太大/太小, 系统直接把它降到最大/最小合法值, 不给出提示.  由于-1是合法的成功返回值, 所以调用之前需要清除errno. 
</code></pre><p><strong>获取一组相关进程的nice值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br></pre></td></tr></table></figure></p>
<pre><code>which参数可以取一下三个值之一: 
1. PRIO_PROCESS 标识进程
2. PRIO_PGRP 标识进程组
3. PRIO_USER 标识用户ID
如果which作用于多个进程,返回优先级最高的. 
</code></pre><p><strong>设置一组相关进程的nice值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-17进程时间"><a href="#8-17进程时间" class="headerlink" title="8.17进程时间"></a>8.17进程时间</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">times</span><span class="params">(struct tms *buf)</span></span>;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/APUE-阅读笔记-第七章-进程环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/19/APUE-阅读笔记-第七章-进程环境/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第七章 进程环境</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-19 17:35:05 / 修改时间：17:46:55" itemprop="dateCreated datePublished" datetime="2019-02-19T17:35:05+08:00">2019-02-19</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第七章-进程环境"><a href="#第七章-进程环境" class="headerlink" title="第七章 进程环境"></a>第七章 进程环境</h2><h3 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h3><pre><code>本章内容: 
    1. 进程执行时,其main函数是如何被调用的.
    2. 命令行参数是如何传递给新程序的
    3. 典型的存储空间布局是什么样子的
    4. 如何分配另外的存储空间
    5. 进程如何使用环境变量
    6. 进程的各种不同终止方案
</code></pre><h3 id="7-2-main函数"><a href="#7-2-main函数" class="headerlink" title="7.2 main函数"></a>7.2 main函数</h3><pre><code>当内核执行c程序时(使用exec执行), 在调用main函数前先调用一个特殊的启动例程.
可执行程序文件将此启动例程指定为程序的起始地址---这是由连接编辑器设置的.
而连接编辑器则由C编译器调用. 
</code></pre><h3 id="7-3-进程终止"><a href="#7-3-进程终止" class="headerlink" title="7.3 进程终止"></a>7.3 进程终止</h3><p><strong>正常终止</strong></p>
<pre><code>1. 从main函数返回
2. 调用exit
3. 调用_exit或者_Exit
4. 最后一个线程从启启动例程返回
5. 从最后一个线程调用pthread_exit
</code></pre><p><strong>异常终止</strong></p>
<pre><code>1. 调用abort
2. 接收到一个信号
3. 最后一个线程对取消请求做出响应
</code></pre><h4 id="1-退出函数"><a href="#1-退出函数" class="headerlink" title="1. 退出函数"></a>1. 退出函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<pre><code>exit 函数总是执行一个标准IO库的清理关闭操作: 对于所有打开流调用fclose函数. 
即: 输出缓冲中的所有数据都被冲洗
</code></pre><p><strong>终止状态未定义</strong></p>
<pre><code>a. 调用以上函数不带终止状态
b. main执行了一个无返回值的return
c. main没有声明返回类型为整型
</code></pre><h4 id="2-函数atexit"><a href="#2-函数atexit" class="headerlink" title="2. 函数atexit"></a>2. 函数atexit</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>进程可以登记多到32个函数, 将由exit调用, 这些函数被称为终止处理程序
其中, atexit函数的参数是一个函数地址, 调用该函数不需要向它传递任何参数, 也没返回值. 
登记顺序和调用顺序相反, 登记多次也会被调用多次.
</code></pre><p><strong>和golang中的defer类似</strong></p>
<pre><code>如果程序调用exec函数族中的任一函数, 则将清除所有已经安装的中终止处理程序
</code></pre><p><img src="/2019/02/19/APUE-阅读笔记-第七章-进程环境/./exec.png" alt="Alt text"></p>
<h3 id="7-4-命令行参数"><a href="#7-4-命令行参数" class="headerlink" title="7.4 命令行参数"></a>7.4 命令行参数</h3><pre><code>没啥好写的...
</code></pre><h3 id="7-5-环境表"><a href="#7-5-环境表" class="headerlink" title="7.5 环境表"></a>7.5 环境表</h3><pre><code>全局变量environ包含了该指针数组的地址
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ</span><br></pre></td></tr></table></figure>
<h3 id="7-6-C程序的存储空间布局"><a href="#7-6-C程序的存储空间布局" class="headerlink" title="7.6 C程序的存储空间布局"></a>7.6 C程序的存储空间布局</h3><pre><code>C程序一直由下列几部分组成:
1. 正文段: 这是由CPU执行的机器指令部分. 只读且可共享. 
2. 初始化`数据段`: 包含了程序中需要明确地赋初值的变量. 
3. 未初始化数据段: 通常称为bss段. 程序开始之前, 内核将此段终端数据初始化为0或者空指针. 
4. 栈: 自动变量以及每次函数调用时所需要保存的信息都存放在此段中. 
5. 堆: 动态存储分配. 
</code></pre><p><img src="/2019/02/19/APUE-阅读笔记-第七章-进程环境/./memory.png" alt="Alt text"></p>
<h3 id="7-7-共享库"><a href="#7-7-共享库" class="headerlink" title="7.7 共享库"></a>7.7 共享库</h3><pre><code>共享库使得可执行文件中不需要包含公用的库函数, 只需要在所有进程都可以引用的存储区中保存这种库例程的一个副本.
程序第一次执行或者第一次调用某个库函数时, 使用动态链接的方法将程序与共享库连接. 
这减少了每个可执行文件的长度, 怎能增加了一些运行时间开销.
另一个优点是使用库的新版本代替老版本时不需要再对使用该库的程序重新连接编辑
使用`-static` 阻止gcc使用共享库
</code></pre><h3 id="7-8-存储空间分配"><a href="#7-8-存储空间分配" class="headerlink" title="7.8 存储空间分配"></a>7.8 存储空间分配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="comment">// 分配指定字节数的存储区, 初始值不确定 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="comment">//为指定数量指定长度的对象分配存储空间, 每一位(bit)都初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"><span class="comment">// 增加或者减少以前分配区的长度, 可能发生拷贝, 初始值不确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-9-环境变量"><a href="#7-9-环境变量" class="headerlink" title="7.9 环境变量"></a>7.9 环境变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>该函数返回一个指针, 指向name=value字符串中的value,
我们应当使用getenv从环境中去一个指定环境变量的值, 而不是直接去访问environ
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 以上函数只支持部分系统</span></span><br></pre></td></tr></table></figure>
<pre><code>1. putenv取形式为name=value的字符串将其放到环境表中, 如果name已经存在, 则删除之前的定义.
2. setenv将name设置为value,  如果已经存在name, 且rewrite非0, 首先删除其现在的定义, 否则不删除
3. unsetenv删除name的定义, 即使不存在这种定义也不算错误
</code></pre><h4 id="修改环境变量导致的内存变化"><a href="#修改环境变量导致的内存变化" class="headerlink" title="修改环境变量导致的内存变化"></a>修改环境变量导致的内存变化</h4><pre><code>1. 删除字符串: 在环境表中找到该指针, 然后将所有后续指针都向环境表首部顺次移动一个位置. 
2. 修改字符串: 
    1. 如果新的value的长度少于或者等于现有value的长度, 则只需要将新字符串复制到原字符串所在空间中
    2. 如果新的value的长度大于现有的value的长度, 调用malloc分配空间, 并将字符串复制到该空间, 使环境表针对name的指针指向新分配区
3. 如果要增加一个新的name, 调用malloc为name=value的字符串分配空间, 然后将字符串复制到该空间中
    1.  如果是第一次增加一个新name, 则必须调用malloc为新的指针表分配空间, 
        接着, 将原来的环境表复制到新的分配区,
        并将指向新的name=value的字符串的指针存放在该指针表的末尾,
        然后又将一个空指针存放在其后, 最后使environ指向新指针表.
        注意: 只复制环境表, 环境表中存储的是指针, 原来的值依旧存储在栈顶之上
    2.  如果不是第一次增加一个新name, 只需要调用realloc
        以分配比原空间多存放一个指针的空间, 
        然后将指向新的name=value字符串的指针存放在该表表尾, 后面跟着一个空指针
</code></pre><h3 id="7-10-函数setjmp和longjmp"><a href="#7-10-函数setjmp和longjmp" class="headerlink" title="7.10 函数setjmp和longjmp"></a>7.10 函数setjmp和longjmp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>; </span><br><span class="line"><span class="comment">// val 用来区分不同的longjmp, val会作为setjmp的返回值</span></span><br></pre></td></tr></table></figure>
<pre><code>用于出现错误时, 直接丢弃中间调用函数的栈帧, 直接重新回到setjmp的位置
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf jmpbuffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        longjmp(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func(a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func1(a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func1(<span class="number">1</span>); <span class="comment">// 普通的出错返回方式, 还需要一层一层回到被调用者函数那里, 最后才回到目的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = setjmp(jmpbuffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setjmp %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf("%d error", x);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    func(<span class="number">1</span>);<span class="comment">// 使用longjmp, 直接回到setjmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自动变量(局部变量), 寄存器变量(register)和易失变量(volatile)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf jmpbuffer;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> autoval;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> regival;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> volaval;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> statval;</span><br><span class="line">    globval = <span class="number">1</span>;</span><br><span class="line">    autoval = <span class="number">2</span>;</span><br><span class="line">    regival = <span class="number">3</span>;</span><br><span class="line">    volaval = <span class="number">4</span>;</span><br><span class="line">    statval = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(jmpbuffer) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"after longjmp:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"globval = %d, autoval = %d, regival %d, volaval = %d, statval = %d\n"</span>, globval, autoval, regival, volaval, statval);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    globval = <span class="number">95</span>;</span><br><span class="line">    autoval = <span class="number">96</span>;</span><br><span class="line">    regival = <span class="number">97</span>;</span><br><span class="line">    volaval = <span class="number">98</span>;</span><br><span class="line">    statval = <span class="number">99</span>;</span><br><span class="line">    f1(autoval, regival, volaval, statval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in f1():\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"globval = %d, autoval = %d, regival %d, volaval = %d, statval = %d\n"</span>, globval, i, j, k, l);</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    longjmp(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc volatile_jmp.c</span></span><br><span class="line"><span class="comment">// gcc -O volatile_jmp.c</span></span><br></pre></td></tr></table></figure>
<pre><code>全局变量, 静态变量, 易失变量不受影响
自动变量和寄存器变量优化前后变化
想要不变化, 使用volatile变成易失变量
</code></pre><h3 id="7-11-函数getrlimit和setrlimit"><a href="#7-11-函数getrlimit和setrlimit" class="headerlink" title="7.11 函数getrlimit和setrlimit"></a>7.11 函数getrlimit和setrlimit</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlptr)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>每一个进程都有一组资源限制, 其中一些可以用getrlimit和setrlimit函数查询或者更改
1. 任何一个进程都可以将一个软限制更改为小于或者等于其硬限制值
2. 任何一个进程都可以降低硬限制值, 但是必须大于或者等于其软限制值
3. 只有超级用户可以提高硬限制值
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/APUE-阅读笔记-第六章-系统数据文件和信息/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/18/APUE-阅读笔记-第六章-系统数据文件和信息/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第六章 系统数据文件和信息</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-18 18:19:17" itemprop="dateCreated datePublished" datetime="2019-02-18T18:19:17+08:00">2019-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-19 17:42:42" itemprop="dateModified" datetime="2019-02-19T17:42:42+08:00">2019-02-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h2><h3 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h3><pre><code>Unix系统的正常运作需要使用大量与系统有关的数据文件.  这些文件都是ASCII文本文件.
但是对于较大的系统, 顺序扫描口令文件很花费时间, 我们需要能够以非ASCII文本格式存放这些文件,
但仍向使用其他文件格式的应用程序提供接口. 对于这些数据文件的可一直接口是本章的主题, 也包含系统标识函数, 时间和日期函数等.
</code></pre><h3 id="6-2-口令文件"><a href="#6-2-口令文件" class="headerlink" title="6.2 口令文件"></a>6.2 口令文件</h3><pre><code>Unix系统口令文件包含了下图所示字段, 这些字段在&lt;pwd.h&gt;中定义的passwd结构中
</code></pre><p><img src="/2019/02/18/APUE-阅读笔记-第六章-系统数据文件和信息/./passwd.png" alt="Alt text"><br>    在Linux中, 该文件中可能有以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名:加密口令:数值用户ID:数值组ID:注释字段:初始工作目录:初始shell</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">squid:x:23:23::/var/spool/squid:/dev/null</span><br><span class="line">nobody:x:65534:65534:Nobody:/home:/bin/sh</span><br><span class="line">sar:x:205:105:Stephen Rago:/home/sar:/bin/bash</span><br></pre></td></tr></table></figure>
<pre><code>1. 通常有一个用户名为root的登录项, 用户ID为0
2. 加密口令字段包含了一个占位符, 但是解密口令字存放在另一个文件中
3. 口令文件箱中的某些字段可能为空.如果为空, 通常意味着该用户没有口令. 
4. shell字段包含了一个可执行程序名, 被用作该用户的登录shell. 
5. 为了阻止一个特定用户登录, 除了使用/dev/null外, 还可以使用/bin/false用作登录shell
6. 使用nobody作为用户名的目的是, 使任何人都可以登录该系统, 但只能访问人人皆可读写的文件.
7. 使用finger命令的某些UNIX系统支持注释字段中的附加信息...感觉没啥用...
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>这两个函数都返回的是passwd结构, 该接口通常是函数内部的静态变量, 
只要调用任意相关函数, 其内容就会被重写. 
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>getpwent</strong></p>
<pre><code>调用getpwent时, 它返回口令文件中的下一个记录项. 每一次调用该函数, 都重写passwd结构. 第一次调用该函数时, 它打开使用的各个文件.
</code></pre><p><strong>setpwent</strong></p>
<pre><code>函数setpwent用来将getpwent的读写地址指向密码文件开头
</code></pre><p><strong>endpwent</strong></p>
<pre><code>endpwent关闭这些文件. 
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nam)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    setpwent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getpwent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, ptr-&gt;pw_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endpwent();</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>函数开始处调用setwent是自我保护性的措施, 一边确保之前有调用者打开过.
</code></pre><h3 id="6-3-阴影文件"><a href="#6-3-阴影文件" class="headerlink" title="6.3 阴影文件"></a>6.3 阴影文件</h3><pre><code>现在某些系统将加密口令存放在另一个通常称为阴影口令的文件中, 该文件`至少要包括`用户名和加密口令.
与该口令相关的其他信息也可以存放到该文件中.
</code></pre><p><img src="/2019/02/18/APUE-阅读笔记-第六章-系统数据文件和信息/./shadow.png" alt="Alt text"></p>
<pre><code>仅有少数几个程序需要访问加密口令, 如login和passwd. 这些程序常常是设置用户ID为root的程序
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="function">struct spwd *<span class="title">getspnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct spwd *<span class="title">getspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-组文件"><a href="#6-4-组文件" class="headerlink" title="6.4 组文件"></a>6.4 组文件</h3><pre><code>Unix组文件包含了下图所示字段, 这些字段包含在&lt;grp.h&gt;中定义的group结构中
</code></pre><p><img src="/2019/02/18/APUE-阅读笔记-第六章-系统数据文件和信息/./group.png" alt="Alt text"></p>
<pre><code>字段**gr_mem是一个指针数组, 其中每个指针指向一个属于该组的用户名, 该数组以null指针结尾
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function">struct group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>这两个函数通常也返回一个静态变量的指针, 每次调用时都重写该静态变量...
如果需要搜索整个组文件, 则需要使用另外几个函数.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-附属组ID"><a href="#6-5-附属组ID" class="headerlink" title="6.5 附属组ID"></a>6.5 附属组ID</h3><pre><code>附属组ID: 我们不仅可以属于口令文件记录项中组ID对应的组, 也可以属于多至16个另外的组. 
文件访问权限检查相应的修改为: 不仅将进程的有效组ID与文件的组ID相比较, 也将所有附属组ID与文件的组ID进行比较...
使用附属组ID的优点是不必显式的经常更改组. 一个用户会参与多个项目, 因此需要同时属于多个组
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroup</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>getgroups将进程所属用户的各附属组ID填写到数组grouplist中, 填写入该数组的附属组ID数最多为gidsetsize个, 实际填写到数组中的附属组ID数由函数返回.
作为一种特殊情况, 如果gidsetsize为0, 则函数只返回附属组ID数, 而对数组grouplist则不做修改..
setgroups可以由超级用户调用以便为调用进程设置附属组ID表. grouplist是组ID数组, ngroups不大于NGROUP_MAX
</code></pre><h3 id="6-8-登录账户记录"><a href="#6-8-登录账户记录" class="headerlink" title="6.8 登录账户记录"></a>6.8 登录账户记录</h3><pre><code>大多数UNIX系统都提供下面两个数据文件 , utmp文件记录当前登录到系统的各个用户,  wtmp文件跟踪各个登录和注销时间. 
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ut_line[<span class="number">8</span>]; <span class="comment">/* tty line: "ttyh0" ... */</span></span><br><span class="line">    <span class="keyword">char</span> ut_name[<span class="number">8</span>]; <span class="comment">/* login name */</span></span><br><span class="line">    <span class="keyword">long</span> ut_time;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>login 程序填写, 注销时擦除</p>
</blockquote>
<h3 id="6-9-系统标识"><a href="#6-9-系统标识" class="headerlink" title="6.9 系统标识"></a>6.9 系统标识</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethostname</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> namelen)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="6-10-时间和日期例程"><a href="#6-10-时间和日期例程" class="headerlink" title="6.10 时间和日期例程"></a>6.10 时间和日期例程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *calptr)</span></span></span><br></pre></td></tr></table></figure>
<p><em>这一章看的价值不大, 需要时当工具查就行</em></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/APUE-阅读笔记-第五章-标准I-O库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/APUE-阅读笔记-第五章-标准I-O库/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第五章 标准I/O库</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-14 11:19:18" itemprop="dateCreated datePublished" datetime="2019-02-14T11:19:18+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-19 17:42:37" itemprop="dateModified" datetime="2019-02-19T17:42:37+08:00">2019-02-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第五章-标准I-O库"><a href="#第五章-标准I-O库" class="headerlink" title="第五章 标准I/O库"></a>第五章 标准I/O库</h2><h3 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h3><pre><code>不仅是UNIX, 很多其他操作系统都实现了标准I/O库, 所以这个库由ISO C标准说明
</code></pre><h3 id="5-2-流和FILE对象"><a href="#5-2-流和FILE对象" class="headerlink" title="5.2 流和FILE对象"></a>5.2 流和FILE对象</h3><pre><code>在第三章中, 所有I/O函数都是围绕文件描述符的. 
当打开一个文件, 返回一个文件描述符, 然后该文件描述符就用于后续的I/O操作.
在标准I/O中, 他们的操作围绕流进行
流的定向决定了所读写的字符是单字节还是多字节的.
当一个流被创建的时候, 并没有被定向.
如果在为定向的流上使用一个`多字节的I/O函数`, 则该流定向设置为`宽定向`的.
如果在为定向的流上使用一个`单字节的I/O函数`, 则该流定向设置为`字节定向`的.
只有两个函数可以改变流的定向, freopen函数清除一个流的定向, fwide函数可用于设置流的定向
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>1. 如果mode参数值为负, fwide将试图使指定的流是字节定向的.
2. 如果mode参数值为正, fwide将试图使指定的流是宽定向的.
3. 如果mode参数值是0, fwide将不试图设置流的定向, 但返回标识该流定向的值

fwide并不改变已经定向的流的定向, 此时fwide无错误返回. 
当打开一个流的时候, 标准I/O函数fopen返回一个指向FILE对象的指针. 该对象通常是一个结构
包含以下信息: 
    1. 实际I/O的文件描述符
    2. 指向用于该流缓冲区的指针
    3. 缓冲区的长度
    4. 当前在缓冲区的字节数
    5. 出错标志
</code></pre><h3 id="5-3-标准输入-标准输出和标准错误"><a href="#5-3-标准输入-标准输出和标准错误" class="headerlink" title="5.3 标准输入/标准输出和标准错误"></a>5.3 标准输入/标准输出和标准错误</h3><pre><code>对一个进程预定义了三个流, 标准输入, 标准输出和标准错误. 
stdin, stdout, stderr分别与STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO对应
</code></pre><h3 id="5-4-缓冲"><a href="#5-4-缓冲" class="headerlink" title="5.4 缓冲"></a>5.4 缓冲</h3><pre><code>标准I/O提供缓冲的目的是尽可能减少使用read和write调用的次数.
也对每个I/O流进行自动的缓冲管理, 避免了应用程序需要考虑这一点所带来的麻烦
</code></pre><hr>
<p><strong>缓冲类型</strong></p>
<pre><code>1. 全缓冲:  在填满标准I/O缓冲区后才进行实际的I/O操作,对于驻留在磁盘上的文件通常是由标准I/O来实施全缓冲的.
2. 行缓冲: 当输入或者输出遇到换行符的时候, 标准I/O进行实际的I/O操作.当流涉及终端时,通常使用行缓冲
3. 不带缓冲: 标准I/O库不对字符进行缓冲存储. 标准错误流通常是不带缓冲的
</code></pre><hr>
<p><strong>ISO 要求的缓冲特征</strong></p>
<pre><code>1. 当且仅当标准输入和标准输出并不指向交互式设备时,他们才是全缓冲的
2. 标准错误绝对不是全缓冲的
</code></pre><hr>
<p><strong>冲洗(flush)</strong></p>
<pre><code>冲洗来说明标准I/O缓冲区的写操作
缓冲区可以由标准I/O例程自动冲洗, 或者调用fflush来冲洗一个流.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 任何时候都可以冲洗一个流</span></span><br></pre></td></tr></table></figure>
<pre><code>以上两个函数用来更改流的缓冲类型
</code></pre><p><strong>setbuf</strong></p>
<pre><code>可以使用setbuf函数打开或者关闭缓冲机制. 
为了带缓冲进行I/O, 参数buf必须指向一个长度为BUFSIZ的缓冲区.(BUFSIZ是定义在&lt;stdio.h&gt;的常量)
此时流就是全缓冲的, 如果与终端设备相关, 那么某些系统也会将其设置为行缓冲的.
为了关闭缓冲,将buf设置为NULL
</code></pre><p><strong>setvbuf</strong></p>
<pre><code>使用setvbuf, 可以精确的说明所需的缓冲类型, 这是由mode参数实现的
_IOFBF  全缓冲
_IOLBF  行缓冲
_IONBF  不带缓冲
如果指定的是不带缓冲的流, 则忽略buf和size参数. 
如果指定全缓冲或者行缓冲, 则buf和size可选择的指定一个缓冲区及其长度.
如果指定的是带缓冲的, 而buf是NULL, 则标准IO库将自动的为该流分配适当长度(BUFSIZ)的缓冲区
</code></pre><p><strong>记得关闭一个流</strong></p>
<h3 id="5-5-打开流"><a href="#5-5-打开流" class="headerlink" title="5.5 打开流"></a>5.5 打开流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> df, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>1.  fopen 函数用来打开一个指定路径的文件
2.  freopen 在一个指定的流上打开一个指定的文件, 如果该流已经打开, 则先关闭该流.
    若该流已经定向, 则使用freopen清除该定向.一般用来打开 标准输入/标准输出/标准错误
3.  fdopen取一个已有的文件描述符,并使一个标准的IO流与该文件描述符相结合. 
    该函数常用于由创建管道和网络通信通道函数返回的描述符.
</code></pre><p><strong>type参数</strong> </p>
<p><img src="/2019/02/14/APUE-阅读笔记-第五章-标准I-O库/./标准IO.png" alt="Alt text"></p>
<pre><code>使用b来区分二进制文件或者文本文件
当以读写打开一个文件时(type中+号), 具有以下限制
1. 如果中间没有fflush, fseek, fsetpos或者rewind, 则在输出的后面不能直接跟随输入
2. 如果中间没有fseek, fsetpos或者rewind, 或者一个输入操作没有到达文件尾端, 则在输入操作之后不能直接跟随输出
</code></pre><p><img src="/2019/02/14/APUE-阅读笔记-第五章-标准I-O库/./标准IO2.png" alt="Alt text"></p>
<pre><code>在指定w或者a类型来创建一个新文件时, 我们无法说明文件的访问权限位,默认rw-rw-rw-
可以使用umask来限制这些权限.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>调用fclose关闭一个打开的流
文件被关闭之前, 冲洗缓冲区中的输出数据, 缓冲区中的任何输入数据被丢失.
如果标准IO已经为该流自动分配了一个缓冲区, 则释放该缓冲区
当进程正常终止时, 所有带未写缓冲区的标准IO流都被冲洗, 所有打开的标准IO流都被关闭
</code></pre><h3 id="5-6-读和写流"><a href="#5-6-读和写流" class="headerlink" title="5.6 读和写流"></a>5.6 读和写流</h3><pre><code>一旦打开了流, 可在三种不同类型的非格式化IO中进行选择, 对其进行读写操作
1. 每次打开一个字符的I/O. 一次读或者写一个字符, 如果流是带缓冲的, 则标准IO函数处理所有缓冲
2. 每次一行的IO. 如果想要一次读或者写一行, 则使用fgets和fputs.
3. 直接IO, fread和fwrite支持这种类型的IO. 
</code></pre><p><strong>输入函数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<pre><code>函数getchar等同于getc(stdin)
getc可以被实现为宏, 而fgetc不可以被实现为宏, so
1. getc的参数不能是具有副作用的表达式, 因为它可能被计算多次
2. 因为fgetc一定是个函数, 所以可以得到地址. 这就允许建fgetc的地址作为一个参数传送给另一个函数
3. 调用fgetc函数所需要的时间比getc要长, 因为调用函数所需的时间通常长于调用宏
</code></pre><p><strong>出错函数</strong></p>
<pre><code>无论是出错还是到达文件结尾, 这三个函数都返回同样的值. 必须调用ferror或者feof
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>大多数实现中, 为每个流在FILE对象中维护了两个标志:
1. 出错标志
2. 文件结束标志

可以调用clearerr清除这两个标志
</code></pre><p><strong>压字符回流</strong></p>
<pre><code>从流中读取出的字符, 可以调用ungetc函数将字符再压送回流中. 不能回送EOF.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>输出函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-7-每次一行I-O"><a href="#5-7-每次一行I-O" class="headerlink" title="5.7 每次一行I/O"></a>5.7 每次一行I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>fgets, 必须指定缓冲区长度n. 该缓冲区总是以null结尾, 
如果行数据大于n, 那么将返回一个不完整的行. 下次调用该函数, 会继续执行该行.

gets是一个不推荐使用的函数. 可能造成缓冲区溢出, 写到缓冲区之后的存储空间中.
另外, gets并不将换行符存储到缓冲区中.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>函数fputs将一个以null字节终止的字符串写到指定的流, 尾端的终止符null不写出. 
puts与fputs的区别是, 写到标准输出流, 且每次调用之后添加一个换行符到标准输出
puts是安全的,但是也应该避免使用
</code></pre><h3 id="5-8-标准I-O的效率"><a href="#5-8-标准I-O的效率" class="headerlink" title="5.8  标准I/O的效率"></a>5.8  标准I/O的效率</h3><pre><code>标准IO的效率并不比直接调用read和write函数慢很多.  标准IO的优点在于不用考虑缓冲及最大IO长度的选择
</code></pre><h3 id="5-9-二进制I-O"><a href="#5-9-二进制I-O" class="headerlink" title="5.9 二进制I/O"></a>5.9 二进制I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>size 是结构的长度, nobj为对象的个数.
只能读同一系统上已写的数据, 不能读其他的系统中数据.
</code></pre><h3 id="5-10-定位流"><a href="#5-10-定位流" class="headerlink" title="5.10 定位流"></a>5.10 定位流</h3><pre><code>三种方法可以用来定位标准I/O流. 
1. ftell和fseek函数, 这两个函数都假定文件的位置可以存放在一个长整型中.
2. ftello和fseeko函数, 文件的偏移量可以不必一定使用长整型. 他们使用off_t数据类型代替了长整型.
3. fgetops和fsetops函数. 
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset , <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>为了定位文本文件, whence一定是SEEK_SET, 并且offset只能是0或者ftell返回的值.
</code></pre><h3 id="5-11-格式化I-O"><a href="#5-11-格式化I-O" class="headerlink" title="5.11 格式化I/O"></a>5.11 格式化I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, cosnt <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>snprintf : 长度超过n都被丢弃.
</code></pre><h3 id="5-12-实现细节"><a href="#5-12-实现细节" class="headerlink" title="5.12 实现细节"></a>5.12 实现细节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 通过文件指针获取文件描述符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_stdio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"enter any character\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (getchar() == EOF) &#123;</span><br><span class="line">        err_sys(<span class="string">"getchar error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"one line to standard error\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    pr_stdio(<span class="string">"stdin"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    pr_stdio(<span class="string">"stdout"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    pr_stdio(<span class="string">"stderr"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"/etc/passwd"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fopen error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getc(fp) == EOF) &#123;</span><br><span class="line">        err_sys(<span class="string">"getc error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_stdio(<span class="string">"/etc/passwd"</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_stdio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stream = %s, "</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (is_unbuffered(fp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unbuffered"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_linebuffered(fp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"line buffered"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fully buffered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", buffer size = %d\n"</span>, buffer_size(fp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_IO_UNBUFFERED)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IO_UNBUFFERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IO_LINE_BUF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__SNBF)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; __SNBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; __SLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_bf._size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_IONBF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _flag __pad[4]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ptr __pad[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _base __pad[2]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IONBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IOLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_base - fp-&gt;_ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> BUFSIZ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> unknown stdio implementation!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-13-临时文件"><a href="#5-13-临时文件" class="headerlink" title="5.13 临时文件"></a>5.13 临时文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串.(只产生一个字符串)
如果传入的参数为NULL, 会将文件名存储在静态区, 如果传入的参数为至少是L_tmpnam个字符的数组, 返回该数组指针.
tmpfile 创建一个临时二进制文件. 但是立即被删除. 看不到的...
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>mkdtemp 函数创建了一个目录, 该目录有一个唯一的名字. 权限为`rwx------ `
mkstemp 函数创建了一个文件, 该文件有一个唯一的名字. 权限为`rw-------`
名字是通过template字符串进行选择的. 这个字符串是后六位设置为XXXXXX的路径名.
</code></pre><h3 id="5-14-内存流"><a href="#5-14-内存流" class="headerlink" title="5.14 内存流"></a>5.14 内存流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>内存流: 虽然仍使用FILE指针进行访问, 但其实并没有底层文件, 所有的IO都是通过在缓冲区与主存之间来回传送字节来完成的.
fmemopen函数允许调用者提供缓冲区用于内存流. 如果buf参数为空, fmemopen函数分配size字节数的缓冲区, 这种情况下, 流关闭, 缓冲区关闭.
type参数控制如何使用流...取值对应基于文件的标准I/O的type参数取值, 但其中有微小的差别.
1.  无论何时以追加写方式打开内存流时, 当前文件的位置设置为缓冲区的第一个null字节.
    如果缓冲区中不存在null字节, 则当前位置就设置为缓冲区结尾的后一个字节.
    当流不是以追加写方式打开时, 当前位置设置为缓冲区的开始位置.
2.  如果buf参数是一个null指针, 打开流进行读或者写都没有任何意义, 因为在这种情况下, 缓冲区是通过fmemopen进行分配的, 找不到缓冲区地址.
3.  任何时候需要增加流缓冲区的数据量以及调用fclose,fflush,fseek, fseeko以及fsetpos时都会在当前位置写入一个null字节
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代码在Mac和Linux上执行的结果不一样...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSZ 48</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BSZ];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'a'</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fmemopen(buf, BSZ, <span class="string">"w+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"fmemopen failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initial buffer contents: %s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before flush: %s\n"</span>, buf);</span><br><span class="line">    fflush(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after flush: %s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'b'</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world"</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after fseek: %s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'c'</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after fseek: %s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **bufp, <span class="keyword">size_t</span> *sizep)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmenstream</span><span class="params">(<span class="keyword">wchar_t</span> **bufp, <span class="keyword">size_t</span> *sizep)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>与fmemopen的区别是, 
1. 创建的流只能写打开
2. 不能指定自己的缓冲区. 通过bufp和sizep参数访问缓冲区地址和大小.
3. 关闭流之后需要自行释放缓冲区
4. 对流添加字节会增加缓冲区大小.
</code></pre><p><strong>遵守的规则</strong></p>
<pre><code>1. 缓冲区地址和长度只有在调用了fclose或者fflush后才有效
2. 这些值只有在下一次流写入或调用fclose前才有效.(这地方是不是有问题啊...)
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第四章 文件和目录 第二部分</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-12 16:21:39" itemprop="dateCreated datePublished" datetime="2019-02-12T16:21:39+08:00">2019-02-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-19 17:42:28" itemprop="dateModified" datetime="2019-02-19T17:42:28+08:00">2019-02-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第四章-文件和目录-第二部分"><a href="#第四章-文件和目录-第二部分" class="headerlink" title="第四章 文件和目录 第二部分"></a>第四章 文件和目录 第二部分</h2><h3 id="4-12-文件长度"><a href="#4-12-文件长度" class="headerlink" title="4.12 文件长度"></a>4.12 文件长度</h3><pre><code>stat结构成员st_size表示以字节为单位的文件的长度.
此字段只对普通文件/目录文件/符号链接有意义
对于符号链接, 文件长度实际上是文件名中的实际字符数
</code></pre><p><strong>文件空洞</strong></p>
<pre><code>关于文件空洞, 实际上是偏移量超过文件尾端, 并写入了数据造成的.
(系统中的du报告的是512字节块的块数或者是1024字节块的块数)
使用实用程序复制空洞文件, 文件空洞会被填满, 实际字节填为0
</code></pre><h3 id="4-13-文件截断"><a href="#4-13-文件截断" class="headerlink" title="4.13 文件截断"></a>4.13 文件截断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>有时我们需要在文件尾端截去一些数据以缩短文件. 
将一个文件的长度阶段为0是一个特例, 在打开文件时使用O_TRUNC标志可以做到这一点.
截断文件可以使用上面的两个文件
如果之前的文件长度超过length, 那么超过length之后的文件内容不能被访问
如果之前的文件长度少于length, 那么文件的长度将增加, 后面的是文件空洞
</code></pre><h3 id="4-14-文件系统"><a href="#4-14-文件系统" class="headerlink" title="4.14 文件系统"></a>4.14 文件系统</h3><pre><code>可以把一个磁盘分成一个或者多个分区, 每个分区可以包含一个文件系统, 如下图
节点是固定长度的记录项, 包含文件的绝大部分信息. 
</code></pre><p><img src="/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/./文件系统1.png" alt="Alt text"></p>
<p><img src="/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/./文件系统2.png" alt="Alt text"></p>
<p><strong>引用计数</strong></p>
<pre><code>如上图所示, 多个目录项指向一个i节点, 每个i节点中都有一个连接计数, 
只有当连接计数减少至0时, 才可以删除该文件(释放文件占用的数据块)
解除文件的连接并不意味着释放该文件占用的磁盘块
stat结构中, 连接计数被保存在`st_nlink`中
</code></pre><p><strong>符号链接</strong></p>
<pre><code>符号链接文件的实际内容(在数据块中)包含了该符号连接所指向的文件的名字
</code></pre><p><strong>i节点</strong></p>
<pre><code>i节点存储文件的所有信息, 包含文件类型, 文件访问权限位, 文件长度和指向文件数据库的指针等.
stat结构的大部分信息都取自i节点. 只有两项重要数据存放在目录项中: 文件名和i节点编号
i节点编号的数据类型是ino_t
</code></pre><p><strong>文件系统隔离</strong></p>
<pre><code>因为目录项中的i节点编号指向同一文件系统中相应的i节点,
一个目录项不能指向了另一个文件系统的i节点. 
这就是为什么ln命令不能跨越文件系统的缘故
</code></pre><p><strong>重命名文件</strong></p>
<pre><code>当不更换文件系统的情况下问一个文件重命名时, 文件的实际内容并未移动. 
只需要构造一个指向现有i节点的新目录项, 并删除老的目录项, 连接计数不会改变.
</code></pre><p><img src="/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/./文件重命名.png" alt="Alt text"></p>
<p><strong>目录文件的连接计数</strong></p>
<pre><code>编号2549的节点, 其类型字段标识它是一个目录, 连接计数为2. 
任何一个叶子目录的连接计数总是2
数值2来自命名该目录的目录项以及该目录中的.项
</code></pre><hr>
<pre><code>编号为1267的i节点, 其类型字段标识它是一个目录, 连接技术大于或者等于3.
大于等于3的原因是: 至少有三个目录项指向它: 命名它的目录, 该目录中的.项, 还有其子目录中的..项
</code></pre><h3 id="4-15-函数link-linkat-unlink-unlinkat和remove"><a href="#4-15-函数link-linkat-unlink-unlinkat和remove" class="headerlink" title="4.15 函数link, linkat, unlink, unlinkat和remove"></a>4.15 函数link, linkat, unlink, unlinkat和remove</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>创建连接</strong></p>
<pre><code>前两个函数创建一个新的目录项newpath, 它引用现有文件existingpath. 
如果newpath已经存在, 则返回出错.
只创建路径中的一个分量, 路径中的其他部分应当已经存在
flag用来决定指向现有符号连接还是指向符号连接指向的文件
创建目录项和增加引用计数应当是一个原子操作
</code></pre><p><strong>删除连接</strong></p>
<pre><code>后两个函数删除目录项, 并将由pathname所引用的文件的链接计数减一.
为了解除对文件的连接, 必须对包含该目录的目录具有写和执行权限
只有链接计数达到0 , 文件才可以删除. 进程打开了文件, 其内容也不能删除.
关闭一个文件时, 内核首先检查打开该文件的进程个数, 如果这个计数达到0 , 再去检查其链接计数
当flag参数设置了AT_REMOVEDIR标志时, 函数可以类似与rmdir那样删除目录.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">"foo"</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlink(<span class="string">"foo"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"unlink error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file unlinked\n"</span>);</span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"done"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>unlink这种特性用来保证即使是在程序崩溃时, 所创建的临时文件也不会被遗留下来.
进程使用open或create创建一个文件, 立即unlink即可
如果filepath是符号链接, 那么只能删除符号链接,而不能删除文件.
没有一个函数能删除符号链接引用的文件
</code></pre><h3 id="4-16-函数rename和renameat"><a href="#4-16-函数rename和renameat" class="headerlink" title="4.16 函数rename和renameat"></a>4.16 函数rename和renameat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>oldname是文件</strong></p>
<pre><code>如果oldname是一个文件, 那么newname不能是一个已经存在的目录,
如果newname已经存在,但不是目录, 则先将该目录项删除, 并将oldname命名为newname.
</code></pre><p><strong>oldname是目录</strong></p>
<pre><code>如果newname已经存在, 那么它必须是一个目录, 而且必须是一个空目录
如果newname已经存在, 且是空目录, 先将其删除, 然后将old命名为newname
且newname不能包含oldname作为其路径前缀, 例如将/usr/foo命名为/usr/foo/test
</code></pre><p><strong>符号链接</strong></p>
<pre><code>如果oldname或newname引用符号链接, 那么处理的是符号链接本身, 不影响引用的文件
</code></pre><p><strong>./..</strong></p>
<pre><code>不能对. / .. 重命名
</code></pre><p><strong>同一文件</strong></p>
<pre><code>如果oldname和newname引用同一文件, 那么函数不做任何更改就返回
</code></pre><h3 id="4-17-符号链接"><a href="#4-17-符号链接" class="headerlink" title="4.17 符号链接"></a>4.17 符号链接</h3><pre><code>符号链接是一个文件的间接指针, 硬链接直接指向文件的i节点.
引入符号链接是为了避免硬链接的一些限制
1. 硬链接通常要求在同一个文件系统中
2. 只有超级用户才能创建指向目录的硬链接
一些函数不支持符号链接, 慎用
</code></pre><h3 id="4-18-创建和读取符号链接"><a href="#4-18-创建和读取符号链接" class="headerlink" title="4.18 创建和读取符号链接"></a>4.18 创建和读取符号链接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>读取</strong></p>
<pre><code>创建一个纸箱actualpath的新目录项sympath
在创建时, 并不要求actualpath存在.且两者并不需要位于同一文件系统中
</code></pre><p><strong>读取</strong></p>
<pre><code>两个函数组合了open, read, close的所有操作.
如果函数成功执行, 返回读入buf的字节数.
在buf中返回的符号链接内容并不以null字节终止
</code></pre><h3 id="4-19-文件的时间"><a href="#4-19-文件的时间" class="headerlink" title="4.19 文件的时间"></a>4.19 文件的时间</h3><pre><code>对每个文件维护三个字段, 他们的意义如下
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:right">说明</th>
<th style="text-align:right">例子</th>
<th style="text-align:center">ls选项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">st_atim</td>
<td style="text-align:right">文件数据的最后访问时间</td>
<td style="text-align:right">read</td>
<td style="text-align:center">-u</td>
</tr>
<tr>
<td style="text-align:left">st_mtim</td>
<td style="text-align:right">文件数据的最后修改时间</td>
<td style="text-align:right">write</td>
<td style="text-align:center">默认</td>
</tr>
<tr>
<td style="text-align:left">st_ctim</td>
<td style="text-align:right">i节点状态的最后更改时间</td>
<td style="text-align:right">chown, chmode</td>
<td style="text-align:center">-c</td>
</tr>
</tbody>
</table>
<pre><code>修改时间是文件内容最后一次被修改的时间
状态更改时间是该文件的i节点最后一次被修改的时间.
</code></pre><h3 id="4-20-函数futimens-utimensat-utimes"><a href="#4-20-函数futimens-utimensat-utimes" class="headerlink" title="4.20 函数futimens, utimensat, utimes"></a>4.20 函数futimens, utimensat, utimes</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p><strong>时间</strong></p>
<pre><code>这两个函数的times数组的第一个元素包含访问时间, 第二元素包含修改时间. 是时间戳
1. 如果times参数是一个空指针,则访问时间和修改时间两者都设置为当前时间
2. 如果times参数指向两个timespec结构的数组, 任意数组元素的tv_nsec字段的值为UTIME_NOW,
相应的时间戳设置为当前时间, 忽略相应的tv_sec字段
3. 如果times参数指向两个timespec结构的数组, 任意数组元素的tv_nsec字段的值为UTIME_OMIT,
相应的时间戳不变, 忽略tv_sec字段
4. 如果times参数指向两个timespec结构的数组, tv_nsec的值既不是UTIME_NOW也不是UTIME_OMIT, 
相应的时间设置为tv_sec和tv_nsec的值
</code></pre><p><strong>权限</strong></p>
<pre><code>1. 如果times参数是一个空指针, 或者任意数组元素的tv_nsec字段的值为UTIME_NOW,
则进程的有效用户ID必须等于该文件的所有者ID, 进程必须对文件具有写权限,
或者进程是一个超级用户进程
2. 如果times参数是一个非空指针,
并且任意tv_nsec字段的值都为既不是UTIME_OMIT又不是UTIME_NOW,
则进程有效用户ID必须等于该文件的所有者ID, 或者进程必须是一个超级用户进程,
对文件只有写权限是不够
3. 如果times参数是一个非空指针, 并且任意tv_nsec字段的值都为UTIME_OMIT,
就不执行任何权限检查
</code></pre><hr>
<pre><code>futimens 函数需要打开文件开更改它的时间,utimensat函数提供了一种使用文件名更改时间的方法.
如果fd是AT_FDCWD, 那么通过当前进程的目录来计算filepath. 
如果pathname是绝对路径, 那么fd将被忽略
utimensat的flag参数来决定是否跟随符号链接
</code></pre><p><strong>utimes</strong></p>
<pre><code>utimes函数对路径名进行操作. times参数是指向包含两个时间戳元素(访问时间和修改时间)的数组的指针.
我们不能对状态更改时间st_ctim指定一个值, 因为调用utimes函数时, 该状态会自动更新
</code></pre><h3 id="4-21-函数mkdir-mkdirat-rmdir"><a href="#4-21-函数mkdir-mkdirat-rmdir" class="headerlink" title="4.21 函数mkdir, mkdirat, rmdir"></a>4.21 函数mkdir, mkdirat, rmdir</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span> <span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>这两个函数创建一个空目录, 其中.和..目录项是自动创建的.
所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>用rmdir只能删除空目录.
</code></pre><h3 id="4-22-读目录"><a href="#4-22-读目录" class="headerlink" title="4.22 读目录"></a>4.22 读目录</h3><pre><code>对目录具有访问权限的任意用户都可以读目录. 但是只有内核才能写目录. 
一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件
</code></pre><h3 id="4-23-函数chdir-fchdir和getcwd"><a href="#4-23-函数chdir-fchdir和getcwd" class="headerlink" title="4.23 函数chdir, fchdir和getcwd"></a>4.23 函数chdir, fchdir和getcwd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>每个进程都有当前工作目录, 此目录是搜索所有相对路径名的起点. 
进程调用上面的两个函数来更改当前工作目录.
只影响调用chdir的程序
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 参数为缓冲区的地址和缓冲区大小(该函数获取当前工作目录的绝对路径)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-24-设备特殊文件"><a href="#4-24-设备特殊文件" class="headerlink" title="4.24 设备特殊文件"></a>4.24 设备特殊文件</h3><h3 id="4-25-文件访问权限位小结"><a href="#4-25-文件访问权限位小结" class="headerlink" title="4.25 文件访问权限位小结"></a>4.25 文件访问权限位小结</h3><p><img src="/2019/02/12/APUE-阅读笔记-第四章-文件和目录-第二部分/./文件访问权限位.png" alt="Alt text"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/RSA-加密算法初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/25/RSA-加密算法初探/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">RSA 加密算法初探</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-25 20:39:12" itemprop="dateCreated datePublished" datetime="2019-01-25T20:39:12+08:00">2019-01-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-28 14:49:08" itemprop="dateModified" datetime="2019-01-28T14:49:08+08:00">2019-01-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/加密-签名-安全/" itemprop="url" rel="index"><span itemprop="name">加密/签名/安全</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RSA-加密算法初探"><a href="#RSA-加密算法初探" class="headerlink" title="RSA 加密算法初探"></a>RSA 加密算法初探</h2><h3 id="1-公钥和私钥的产生"><a href="#1-公钥和私钥的产生" class="headerlink" title="1. 公钥和私钥的产生"></a>1. 公钥和私钥的产生</h3><pre><code>1. 随机选择两个大的素数p!=q, 计算N=p*q
2. 根据欧拉函数, 求得 r=φ(N)=φ(p)φ(q)=(p-1)*(q-1)
3. 选择一个小于r且与r互质的整数e, 并求得e关于r的模逆元, 命名为d. 即d*e%r=1
4. 将p和q的记录销毁
5. (N,e)是公钥, (N,d)是私钥
</code></pre><p><strong>一些基础知识</strong></p>
<pre><code>1. n的欧拉函数指的是1~n-1之间与n互质的数的个数
2. 一个素数n的欧拉函数等于n-1
3. (a^b)%p=(a^b%φ(p))%p
</code></pre><h3 id="2-加密消息"><a href="#2-加密消息" class="headerlink" title="2. 加密消息"></a>2. 加密消息</h3><pre><code>1. 消息发送方知道公钥(N,e)
2. 消息发送方将消息转化为小于N的非负整数n(比如可以将字转化为该字的Unicode码, 可以分几段, 然后将每一段转化为n)
3. 用公式 c=n^e%N
4. 将消息发送给消息接受者
</code></pre><h3 id="3-解密消息"><a href="#3-解密消息" class="headerlink" title="3. 解密消息"></a>3. 解密消息</h3><pre><code>1. 消息接受者接收到消息, 拿到n
2. 利用公式n=c^d%N来将c转化为n. (n = (c^d)%N = ((n^e)^d)%N = (n^(de%φ(N)))%N = (n^(de%r))%N = n%N = n)
</code></pre><h3 id="4-签名消息"><a href="#4-签名消息" class="headerlink" title="4. 签名消息"></a>4. 签名消息</h3><p><strong>发送者</strong></p>
<pre><code>1. 计算消息的散列值(MD5,sha1)
2. 加密散列值, 并将加密后的散列值(签名)加在消息后面.
3. 发送消息
</code></pre><p><strong>接受者</strong></p>
<pre><code>1. 接受消息
2. 使用公钥解密这个散列值
3. 计算消息的散列值, 比较两个散列值是否相同. 
</code></pre><p><strong>意义</strong></p>
<pre><code>签名消息可以保证消息在传递过程中没有被伪造, 也没有人篡改消息
加密/解密消息可以保证消息在传递过程中不会被他人获取
其实公钥和私钥都能用来加密和解密(理论上是如此, 毕竟逆元是相互的, 但不知安全上是否有影响), 但一定有一个不公开...
</code></pre><h3 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h3><pre><code>公钥(N,e)是公开的, 加密消息c可能被获取. 但是想解密还需要私钥, 虽然可以通过N分解出pq来算出私钥, 
但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在
目前认为N足够大, 黑客就没办法了.
当前推荐N的长度至少为2048位
</code></pre><ul>
<li>以上信息摘自<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a></li>
</ul>
<hr>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/阿里云消息服务MNS-EndPoint签名认证-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/23/阿里云消息服务MNS-EndPoint签名认证-Golang/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">阿里云消息服务MNS EndPoint签名认证 Golang</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-23 15:06:11 / 修改时间：15:49:46" itemprop="dateCreated datePublished" datetime="2019-01-23T15:06:11+08:00">2019-01-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/加密-签名-安全/" itemprop="url" rel="index"><span itemprop="name">加密/签名/安全</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="阿里云消息服务MNS-EndPoint签名认证-Golang"><a href="#阿里云消息服务MNS-EndPoint签名认证-Golang" class="headerlink" title="阿里云消息服务MNS EndPoint签名认证 Golang"></a>阿里云消息服务MNS EndPoint签名认证 Golang</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司业务, 需要进行媒体转码服务, 转码之后需要接受阿里云的回调, 我们采用<a href="https://help.aliyun.com/document_detail/44602.html?spm=a2c4g.11186623.6.628.7b4840d6n7oJN6" target="_blank" rel="noopener">主题通知方式接受消息</a><br>此时需要为阿里云提供一个暴露在公网上面的接口, 所以要避免非法的攻击调用. 此时使用阿里的<a href="https://help.aliyun.com/document_detail/27488.html?spm=a2c4g.11186623.2.11.663d440bGv2Qab" target="_blank" rel="noopener">EndPoint签名认证</a><br>文档中已经有Java代码是如何进行验证的, 我在这里只是做了个转换. </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>从x-mns-signing-cert-url中取出base64加密后的url, 解密, 获得url</li>
<li>http请求url获取pem证书, 解析证书, 获取<strong>公钥</strong></li>
<li>从header中获取<strong>待签名的字符串</strong></li>
<li>从header中获取加密后的Authorization, 解密, 获得<strong>待验证的签名</strong></li>
<li>sha1对<strong>待签名的字符串</strong>sha1加密, 进行sha1rsa签名, 与<strong>待验证的签名</strong>对比</li>
</ul>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">authenticate</span><span class="params">(String method, String uri, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取证书的URL</span></span><br><span class="line">            <span class="keyword">if</span> (!headers.containsKey(<span class="string">"x-mns-signing-cert-url"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"x-mns-signing-cert-url Header not found"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String cert = headers.get(<span class="string">"x-mns-signing-cert-url"</span>);</span><br><span class="line">            <span class="keyword">if</span> (cert.isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"x-mns-signing-cert-url empty"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cert = <span class="keyword">new</span> String(Base64.decodeBase64(cert));</span><br><span class="line">            System.out.println(<span class="string">"x-mns-signing-cert-url:\t"</span> + cert);</span><br><span class="line">            <span class="comment">//根据URL获取证书，并从证书中获取公钥</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(cert);</span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(conn.getInputStream());</span><br><span class="line">            CertificateFactory cf = CertificateFactory.getInstance(<span class="string">"X.509"</span>);</span><br><span class="line">            Certificate c = cf.generateCertificate(in);</span><br><span class="line">            PublicKey pk = c.getPublicKey();</span><br><span class="line">            <span class="comment">//获取待签名字符串</span></span><br><span class="line">            String str2sign = getSignStr(method, uri, headers);</span><br><span class="line">            System.out.println(<span class="string">"String2Sign:\t"</span> + str2sign);</span><br><span class="line">            <span class="comment">//对Authorization字段做Base64解码</span></span><br><span class="line">            String signature = headers.get(<span class="string">"Authorization"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] decodedSign = Base64.decodeBase64(signature);</span><br><span class="line">            <span class="comment">//认证</span></span><br><span class="line">            java.security.Signature signetcheck = java.security.Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">            signetcheck.initVerify(pk);</span><br><span class="line">            signetcheck.update(str2sign.getBytes());</span><br><span class="line">            Boolean res = signetcheck.verify(decodedSign);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSignStr</span><span class="params">(String method, String uri, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(method);</span><br><span class="line">        sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">"Content-md5"</span>));</span><br><span class="line">        sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">"Content-Type"</span>));</span><br><span class="line">        sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">"Date"</span>));</span><br><span class="line">        sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"x-mns-"</span>)) &#123;</span><br><span class="line">                tmp.add(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(tmp);</span><br><span class="line">        <span class="keyword">for</span> (String kv : tmp) &#123;</span><br><span class="line">            sb.append(kv);</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(uri);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">safeGetHeader</span><span class="params">(Map&lt;String, String&gt; headers, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headers.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headers.get(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SignDemo sd = <span class="keyword">new</span> SignDemo();</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">"Authorization"</span>, <span class="string">"Mko2Azg9fhCw8qR6G7AeAFMyzjO9qn7LDA5/t9E+6X5XURXTqBUuhpK+K55UNhrnlE2UdDkRrwDxsaDP5ajQdg=="</span>);</span><br><span class="line">        headers.put(<span class="string">"Content-md5"</span>, <span class="string">"M2ViOTE2ZDEyOTlkODBjMjVkNzM4YjNhNWI3ZWQ1M2E="</span>);</span><br><span class="line">        headers.put(<span class="string">"Content-Type"</span>, <span class="string">"text/xml;charset=utf-8"</span>);</span><br><span class="line">        headers.put(<span class="string">"Date"</span>, <span class="string">"Tue, 23 Feb 2016 09:41:06 GMT"</span>);</span><br><span class="line">        headers.put(<span class="string">"x-mns-request-id"</span>, <span class="string">"56CC2932F0E3D5BD530685CB"</span>);</span><br><span class="line">        headers.put(<span class="string">"x-mns-signing-cert-url"</span>, <span class="string">"aHR0cDovL21uc3Rlc3Qub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS94NTA5X3B1YmxpY19jZXJ0aWZpY2F0ZS5wZW0="</span>);</span><br><span class="line">        headers.put(<span class="string">"x-mns-version"</span>, <span class="string">"2015-06-06"</span>);</span><br><span class="line">        Boolean res = sd.authenticate(<span class="string">"POST"</span>, <span class="string">"/notifications"</span>, headers);</span><br><span class="line">        System.out.println(<span class="string">"Authenticate result:"</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Golang代码"><a href="#Golang代码" class="headerlink" title="Golang代码"></a>Golang代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto"</span></span><br><span class="line">	<span class="string">"crypto/rsa"</span></span><br><span class="line">	<span class="string">"crypto/sha1"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"encoding/base64"</span></span><br><span class="line">	<span class="string">"encoding/pem"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AliNotification</span><span class="params">(method <span class="keyword">string</span>, uri <span class="keyword">string</span>, header http.Header)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提取url , 获取证书, 解析出公钥</span></span><br><span class="line">	urlBase64 := header.Get(<span class="string">"x-mns-signing-cert-url"</span>)</span><br><span class="line">	<span class="keyword">if</span> urlBase64 == <span class="string">""</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"x-mns-signing-cert-url Header not found"</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"x-mns-signing-cert-url Header not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	body, err := base64.StdEncoding.DecodeString(urlBase64)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"解码失败"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"解码失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	certUrl := <span class="keyword">string</span>(body)</span><br><span class="line">	log.Println(<span class="string">"x-mns-signing-cert-url:\t"</span>, certUrl)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求url, 获得证书</span></span><br><span class="line">	resp, err := http.Get(certUrl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"请求x-mns-signing-cert-url失败"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"请求x-mns-signing-cert-url失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err = ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"解析x-mns-signing-cert-url失败"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"解析x-mns-signing-cert-url失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析证书</span></span><br><span class="line">	p, rest := pem.Decode(body)</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"获取公钥失败"</span>, <span class="keyword">string</span>(rest))</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"获取公钥失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	cert, err := x509.ParseCertificate(p.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"证书文件格式不合法, 解析失败"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"证书文件格式不合法, 解析失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	publicKey, ok := cert.PublicKey.(*rsa.PublicKey)</span><br><span class="line">	<span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"公钥格式不正确"</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"公钥格式不正确"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(cert.PublicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取待签名字符串</span></span><br><span class="line">	str := <span class="string">""</span></span><br><span class="line">	str = str + method + <span class="string">"\n"</span></span><br><span class="line">	str = str + header.Get(<span class="string">"Content-md5"</span>) + <span class="string">"\n"</span></span><br><span class="line">	str = str + header.Get(<span class="string">"Content-Type"</span>) + <span class="string">"\n"</span></span><br><span class="line">	str = str + header.Get(<span class="string">"Date"</span>) + <span class="string">"\n"</span></span><br><span class="line">	<span class="keyword">var</span> arr sort.StringSlice</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> header &#123;</span><br><span class="line">		<span class="comment">// golang 的header.Set方法会将header里面key的首字母大写, 所以还要转换一下, 好傻</span></span><br><span class="line">		k = strings.ToLower(k)</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(k, <span class="string">"x-mns-"</span>) &amp;&amp; <span class="built_in">len</span>(v) != <span class="number">0</span> &#123;</span><br><span class="line">			arr = <span class="built_in">append</span>(arr, k+<span class="string">":"</span>+v[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		str = str + arr[i] + <span class="string">"\n"</span></span><br><span class="line">	&#125;</span><br><span class="line">	str += uri</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Authorization字段做Base64解码</span></span><br><span class="line">	signature := header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line">	decodeSign, err := base64.StdEncoding.DecodeString(signature)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"解码失败"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"解码失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">"String2Sign:\t"</span> + str)</span><br><span class="line"></span><br><span class="line">	hashed := sha1.Sum([]<span class="keyword">byte</span>(str))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 认证</span></span><br><span class="line">	<span class="keyword">return</span> rsa.VerifyPKCS1v15(publicKey, crypto.SHA1, hashed[<span class="number">0</span>:sha1.Size], decodeSign)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	header := <span class="built_in">make</span>(http.Header)</span><br><span class="line">	header.Set(<span class="string">"Authorization"</span>, <span class="string">"Mko2Azg9fhCw8qR6G7AeAFMyzjO9qn7LDA5/t9E+6X5XURXTqBUuhpK+K55UNhrnlE2UdDkRrwDxsaDP5ajQdg=="</span>)</span><br><span class="line">	header.Set(<span class="string">"Content-md5"</span>, <span class="string">"M2ViOTE2ZDEyOTlkODBjMjVkNzM4YjNhNWI3ZWQ1M2E="</span>)</span><br><span class="line">	header.Set(<span class="string">"Content-Type"</span>, <span class="string">"text/xml;charset=utf-8"</span>)</span><br><span class="line">	header.Set(<span class="string">"Date"</span>, <span class="string">"Tue, 23 Feb 2016 09:41:06 GMT"</span>)</span><br><span class="line">	header.Set(<span class="string">"x-mns-request-id"</span>, <span class="string">"56CC2932F0E3D5BD530685CB"</span>)</span><br><span class="line">	header.Set(<span class="string">"x-mns-signing-cert-url"</span>, <span class="string">"aHR0cDovL21uc3Rlc3Qub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS94NTA5X3B1YmxpY19jZXJ0aWZpY2F0ZS5wZW0="</span>)</span><br><span class="line">	header.Set(<span class="string">"x-mns-version"</span>, <span class="string">"2015-06-06"</span>)</span><br><span class="line">	log.Println(AliNotification(<span class="string">"POST"</span>, <span class="string">"/notifications"</span>, header))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/APUE-阅读笔记-第四章-文件和目录-第一部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/21/APUE-阅读笔记-第四章-文件和目录-第一部分/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">APUE 阅读笔记 第四章 文件和目录 第一部分</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-21 23:10:23" itemprop="dateCreated datePublished" datetime="2019-01-21T23:10:23+08:00">2019-01-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-25 20:36:38" itemprop="dateModified" datetime="2019-01-25T20:36:38+08:00">2019-01-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/APUE阅读笔记/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>周六写的东西, 忘了发. 周日躺尸一天, 今天比较忙...... 未更新, 发布周六学习的内容
</code></pre><h2 id="第四章-文件和目录-第一部分"><a href="#第四章-文件和目录-第一部分" class="headerlink" title="第四章 文件和目录 第一部分"></a>第四章 文件和目录 第一部分</h2><h3 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h3><pre><code>1. 本章描述文件系统的其他特征和文件的性质
2. 了解文件的所有属性
3. 说明修改这个属性的各个函数
4. Unix文件系统的结构以及符号链接
5. 对目录进行操作的各个函数
6. 以降序便利目录层次结构的函数
</code></pre><h3 id="4-2-函数stat-fstat-fstatat-和lstat"><a href="#4-2-函数stat-fstat-fstatat-和lstat" class="headerlink" title="4.2 函数stat, fstat, fstatat, 和lstat"></a>4.2 函数stat, fstat, fstatat, 和lstat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat * <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 关于restrict: C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，</span></span><br><span class="line"><span class="comment">// 对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</span></span><br></pre></td></tr></table></figure>
<p><strong>区别</strong></p>
<pre><code>stat函数返回与命名文件相关的信息结构
fstat函数获得已在描述符fd上打开文件的有关信息
lstat函数类似于stat, 但当命名文件是一个符号链接时,返回该链接信息, 而不是该链接指向的文件的信息
fstatat 函数为一个相对于当前打开目录(由fd指向)的路径名返回文件统计信息. 
</code></pre><p><strong>fstatat的flag</strong></p>
<pre><code>flag参数控制着是否跟随一个符号链接
AT_SYMLINK_NOFOLLOW标志被设置时, 不跟随.
否则跟随
如果fd参数的值AT_FDCWD, 
    1. pathname是相对路径, fstatat会计算对于当前目录的pathname参数.
    2. pathname是绝对路径, fd参数就会被忽略
</code></pre><p><strong>buf</strong></p>
<pre><code>函数通过填充buf来返回信息
</code></pre><h3 id="4-3-文件类型"><a href="#4-3-文件类型" class="headerlink" title="4.3 文件类型"></a>4.3 文件类型</h3><p><strong>普通文件</strong></p>
<pre><code>包含某种形式的数据. 
普通文本和二进制数据都是普通文件, 对Linux内核而言并无区别.
二进制可执行文件有特定的格式, 便于内核解析执行
</code></pre><p><strong>目录文件</strong></p>
<pre><code>包含其他文件的名字和指向这些文件有关信息的指针.
只有内核可以直接写目录文件, 进程必须使用函数来能更改目录
</code></pre><p><strong>块特殊文件</strong></p>
<pre><code>提供对设备带缓冲的访问, 每次访问以固定长度为单位进行
</code></pre><p><strong>字符特殊文件</strong></p>
<pre><code>提供对设备不带缓冲的访问,长度可变.
系统中的设备要么是字符特殊文件, 要么是块特殊文件
</code></pre><p><strong>FIFO</strong></p>
<pre><code>这种类型的文件用于进程间通信. 有时称之为命名管道
</code></pre><p><strong>套接字</strong></p>
<pre><code>用于进程间的网络通信, 也可用于一台主机进程之间的进程之间通信
</code></pre><p><strong>符号链接</strong></p>
<pre><code>用于指向另一个文件
文件类型信息存储在stat结构中的st_mode成员中. 
使用以下宏判断是文件类型
    1. S_ISBLK(m)       block special
    2. S_ISCHR(m)       char special
    3. S_ISDIR(m)       directory
    4. S_ISFIFO(m)    fifo or socket
    5. S_ISREG(m)       regular file
    6. S_ISLNK(m)       symbolic link
    7. S_ISSOCK(m)    socket
    8. S_TYPEISMQ(buf)        Test for a message queue
    9. S_TYPEISSEM(buf)    Test for a semaphore
    10. S_TYPEISSHM(buf)    Test for a shared memory object
</code></pre><h3 id="4-4-设置用户ID和设置组ID"><a href="#4-4-设置用户ID和设置组ID" class="headerlink" title="4.4 设置用户ID和设置组ID"></a>4.4 设置用户ID和设置组ID</h3><p><strong>与进程相关联的ID</strong></p>
<pre><code>1. 标识我们是谁
    - 实际用户ID
    - 实际组ID
2. 决定我们的文件的访问属性
    - 有效用户ID
    - 有效组ID
    - 附属组ID
3. 由exec函数保存
    - 保存的设置用户ID
    - 保存的设置组ID


通常, 进程的有效用户ID就是实际用户ID, 有效组ID通常是实际组ID
但是可以设置st_mode一个特殊标志, 含义是:
当执行此文件时, 进程的(有效用户ID/有效组ID)为文件所有者的(用户ID/组ID). `设置用户ID/组ID`
通过这种方式, 可以使普通用户获得root权限.
若文件所有者是超级用户, 并且设置了该文件的设置用户ID, 
那么当该程序文件由一个进程执行时, 该进程具有超级用户权限
</code></pre><p><strong>设置需谨慎</strong></p>
<pre><code>设置用户ID和设置组ID都包含在st_mode值中, 可以分别用s__ISUID和S_ISGID设置
</code></pre><h3 id="4-5-文件访问权限"><a href="#4-5-文件访问权限" class="headerlink" title="4.5 文件访问权限"></a>4.5 文件访问权限</h3><pre><code>st_mode值中包含了对文件(所有类型的文件)的访问权限位. 
每个文件有9个权限位: 
    1. 用户读/写/执行
    2. 组读/写/执行
    3. 其他读/写/执行
</code></pre><hr>
<p><strong>规则</strong></p>
<pre><code>1. 用任意名字打开任意类型的文件时, 需要对从文件所在的目录 -&gt; 根目录的所有目录都具有执行权限. 读权限允许我们读目录,获得在该目录下所有文件的列表.
2. 对一个文件的读权限决定了是否能够对当前文件进行读操作
3. 对一个文件的写权限决定了是否能够对当前文件进行写操作
4. 打开文件设置O_TRUNC必须对该文件具有写权限
5. 为了在目录中创建一个新文件, 必须对该目录具有执行权限和写权限
6. 为了删除一个现有的文件, 需要对目录具有写文件和执行权限, 对该文件本身不需要读写权限
7. 如果用7个exec函数中的任意一个执行某个文件, 必须对该文件有可执行权限, 文件必须是普通文件
</code></pre><hr>
<p><strong>权限检测</strong></p>
<pre><code>1. 检查进程的有效用户ID是否为0,
2. 进程的有效用户ID等于文件的所有者ID
3. 进程的有效组ID或进程的附属组ID等于文件的组ID
4. 其他用户
</code></pre><h3 id="4-6-新文件和目录的所有权"><a href="#4-6-新文件和目录的所有权" class="headerlink" title="4.6 新文件和目录的所有权"></a>4.6 新文件和目录的所有权</h3><pre><code>1. 新文件的用户ID设置为进程的有效用户ID. 
2. 新文件的组ID可以使进程的有效组ID
3. 新文件的组ID可以是它所在目录的组ID
</code></pre><h3 id="4-7-函数access和faccessat"><a href="#4-7-函数access和faccessat" class="headerlink" title="4.7 函数access和faccessat"></a>4.7 函数access和faccessat</h3><pre><code>当open函数打开一个文件时, 内核以进程的有效用户ID和有效组ID为基础执行其访问测试权限
但是, 有时进程也希望按实际用户ID和实际组ID来测试其访问功能.
access和faccessat函数就是满足这种需求的
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><strong>mode</strong></p>
<pre><code>测试文件是否存在 F_OK
测试读权限 R_OK
测试写权限 W_OK
测试执行权限 X_OK
</code></pre><p><strong>异同</strong></p>
<pre><code>faccessat 函数和access函数在下面两种情况下是相同的.
1. pathname参数为绝对路径, 
2. fd参数取值为AT_FDCWD而pathname为相对路径
</code></pre><p><strong>flag</strong></p>
<pre><code>flag参数可以用以改变faccessat的行为, 如果flag设置为AT_EACCESS ,
访问检查用的是调用进程的有效用户ID和有效组ID, 而不是实际用户ID和实际组ID
</code></pre><h3 id="4-8-函数umask"><a href="#4-8-函数umask" class="headerlink" title="4.8 函数umask"></a>4.8 函数umask</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>umask函数为进程设置文件模式创建屏蔽字, 并返回之前的值
其中cmask是4.5中9个常量中的若干按位或构成的
在文件模式创建屏蔽字中为1的位, 文件中相应的为一定被关闭
测试代码如下:
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (creat(<span class="string">"foo"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"creat error for foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    <span class="keyword">if</span> (creat(<span class="string">"bar"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"creat error for bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后, 发现foo是拥有rw-rw-rw-的权限的<br>但是umask屏蔽了<code>S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</code> bar只有rw——-的权限</p>
<h3 id="4-9-函数chmod-fchmod-fchmodat"><a href="#4-9-函数chmod-fchmod-fchmodat" class="headerlink" title="4.9 函数chmod, fchmod, fchmodat"></a>4.9 函数chmod, fchmod, fchmodat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmode</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodeat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode,<span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>chmod 在指定的文件上操作, fchmod在打开的文件上操作, 
fchmodat函数与chmod函数在下面两种情况下是相同的:
1. pathname参数是绝对路径, 
2. fd参数取值为AT_FDCWD, 而pathname为相对路径
flag参数可以改变fchmodeat的行为,当设置了AT_SYMLINK_NOFOLLOW标志时, fchmodeat并不会跟随符号链接
chmod只是更改i节点最近一次被修改的时间, ls -l列出的是最后修改文件内容的时间
</code></pre><p><strong>新增标志位</strong></p>
<pre><code>1. 执行时设置用户ID S_ISUID
2. 执行时设置组ID S_ISGID
3. 保存正文(粘着位) S_ISVTX
4. S_IRWXU  用户读写执行
5. S_IRWXG  组读写执行
6. S_IRWXO  其他读写执行
</code></pre><h3 id="4-10-粘着位"><a href="#4-10-粘着位" class="headerlink" title="4.10 粘着位"></a>4.10 粘着位</h3><pre><code>如果一个可执行文件的这一位被设置了, 那么当该程序第一次被执行, 
在其终止时, 程序正文部分(机器指令)的一个副本仍被保存在交换区.
使得下一次执行该程序时能够较快的将其装载入内存.
现在的系统扩展了粘着位的适用范围, Single Unix Specification允许针对目录设置粘着位.
如果对一个目录设置了粘着位, 只有对该目录具有写权限的用户且满足下列条件之一,
才能`删除`或者`重命名`该目录下的文件(但是可以新建文件呀)
1. 拥有该文件
2. 拥有此目录
3. 是超级用户
</code></pre><h3 id="4-11-函数chown-fchown-fchownat和lchown"><a href="#4-11-函数chown-fchown-fchownat和lchown" class="headerlink" title="4.11 函数chown, fchown, fchownat和lchown"></a>4.11 函数chown, fchown, fchownat和lchown</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, uid_towner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>他们的区别主要在于绝对路径与相对路径, 或者是改变符号链接或者符号链接指向的文件的所有者
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default.png" alt="flyfish">
            
              <p class="site-author-name" itemprop="name">flyfish</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flyfish</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
