<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="flyfish&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="flyfish&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flyfish&#39;s blog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>flyfish's blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"><i class="fa fa-bookmark-o"></i>&nbsp;flyfish's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/have-fun.html" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>元素周期表</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/19/Redis面试汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/01/19/Redis面试汇总/" class="post-title-link" itemprop="http://yoursite.com/index.html">Redis面试汇总</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-19 08:59:28 / 修改时间：09:00:19" itemprop="dateCreated datePublished" datetime="2021-01-19T08:59:28+08:00">2021-01-19</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-知识点"><a href="#Redis-知识点" class="headerlink" title="Redis 知识点"></a>Redis 知识点</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时带来的内存重分配次数<ul>
<li>空间预分配: 在需要扩容的条件下，如果内容长度小于1M，那么空闲空间的长度等于内容长度，否则，空闲空间的长度为1M</li>
<li>惰性空间释放: 通过API释放空间</li>
</ul>
</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li>
<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li>
<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。<br>负载因子: 元素数量/桶数量</p>
</blockquote>
<p>哈希表执行rehash的步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）;</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>
<li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li>
</ol>
<p>扩展的条件: </p>
<ol>
<li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于<code>1</code>。</li>
<li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于<code>5</code>。</li>
</ol>
<p>收缩的条件: </p>
<ul>
<li>当哈希表的负载因子小于<code>0.1</code>时，程序自动开始对哈希表执行收缩操作。</li>
</ul>
<p>渐进式rehash: 每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]</p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><blockquote>
<p>每个节点由<code>元素</code>, <code>分数</code>, <code>指向上一个节点的指针</code>, <code>各个层</code>组成</p>
</blockquote>
<ol>
<li>新增:</li>
<li>删除:</li>
<li>查找: </li>
</ol>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><blockquote>
<p>包含编码方式, 元素数量, 保存元素的数组等. 其中元素从小到达有序排列.<br>其中插入和删除的复杂度都是O(N)</p>
</blockquote>
<p>整数集合的升级: </p>
<ol>
<li>扩容: 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>转换: 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li>
<li>插入: 将新元素添加到底层数组里面</li>
</ol>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><blockquote>
<p>特殊编码的连续内存块组成的顺序型数据结构. 查询时的复杂度为O(n)或者O(n^2)</p>
</blockquote>
<ol>
<li>zlbytes: 记录压缩列表占用的总字节数</li>
<li>zltail: 记录尾节点距离首节点的偏移量</li>
<li>zllen: 记录节点数量</li>
<li>entry: 列表节点<ul>
<li>previous_entry_length: 记录压缩列表前一个节点的长度</li>
<li>encoding: 节点的数据类型及长度, 最高两位保存编码, 后面的保存长度</li>
<li>content: 保存节点的值.</li>
</ul>
</li>
<li>zlend: 压缩列表末尾</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><ul>
<li>整数值, 且可以用long类型来保存, 那么编码为int</li>
<li>字符串值, 长度大于32字节, raw方式, 将使用sds来保存</li>
<li>其他, embstr<ul>
<li>只需要一次内存分配, raw两次(一次sds的, 一次对象的. )</li>
<li>只需要一次内存释放</li>
<li>都保存在一块连续的内存里面, 能更好的利用缓存的优势</li>
</ul>
</li>
</ul>
<p>编码转换: </p>
<ol>
<li>int 升级为 raw</li>
<li>所有对embstr的修改都会升级为raw</li>
</ol>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><ul>
<li>压缩列表实现: 所有字符串元素都小于64字节, 元素数量小于512个</li>
<li>链表实现: 其他场景使用链表. </li>
</ul>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><ul>
<li>压缩列表实现: 先将保存了键的压缩列表节点推入到压缩列表尾, 再将保存了值的压缩列表节点推入压缩列表尾.<ul>
<li>所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个.</li>
</ul>
</li>
<li>字典实现: 其他场景都使用字典实现. </li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul>
<li>整数集合实现<ul>
<li>都是整数值</li>
<li>元素个数小于512个</li>
</ul>
</li>
<li>hashtable实现</li>
</ul>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><ul>
<li>压缩列表实现<ul>
<li>均小于64字节</li>
<li>元素个数小于128个.</li>
</ul>
</li>
<li>跳跃表实现: 同时使用字典和跳跃表, 同时保留范围操作的优势和单个查询的优势.</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/24/Golang汇编基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/24/Golang汇编基础/" class="post-title-link" itemprop="http://yoursite.com/index.html">Golang汇编基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-24 10:26:15" itemprop="dateCreated datePublished" datetime="2020-10-24T10:26:15+08:00">2020-10-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-10-27 08:44:10" itemprop="dateModified" datetime="2020-10-27T08:44:10+08:00">2020-10-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-寄存器基础"><a href="#一-寄存器基础" class="headerlink" title="一. 寄存器基础."></a>一. 寄存器基础.</h2><blockquote>
<p>寄存器（Register）是中央处理器内用来暂存指令、数据和地址的电脑存储器。寄存器的存贮容量有限，读写速度非常快。在计算机体系结构里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速计算机程序的运行。—-来自Wikipedia.</p>
</blockquote>
<p>16位CPU通用寄存器通常有8个, 分别是: AX, BX, CX, DX, BP, SP, SI, DI<br>32位CPU通用寄存器通常有8个, 分别是: EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI(E表示Extended) </p>
<h3 id="1-1-数据寄存器-AX-BX-CX-DX"><a href="#1-1-数据寄存器-AX-BX-CX-DX" class="headerlink" title="1.1 数据寄存器 AX, BX, CX, DX"></a>1.1 数据寄存器 AX, BX, CX, DX</h3><p>寄存器<code>AX</code>通常称为累加器, 用于存储计算产生的中间结果, 避免每次计算都要读写内存<br>寄存器<code>BX</code>被称为基地址寄存器, 用于存储指针<br>寄存器<code>CX</code>被称为计数寄存器, 在循环和字符串操作时, 用于控制循环次数.<br>寄存器<code>DX</code>被称为数据寄存器, 在进行乘除运算是, 可以作为默认的操作数参与运算, 也可以存放I/O的端口地址. </p>
<h3 id="1-2-指针寄存器-BP-SP"><a href="#1-2-指针寄存器-BP-SP" class="headerlink" title="1.2 指针寄存器 BP, SP"></a>1.2 指针寄存器 BP, SP</h3><p>寄存器<code>BP</code>被称为基址指针寄存器,<br>寄存器<code>SP</code>被称为堆栈指针寄存器,</p>
<h3 id="1-3-变址寄存器-SI-DI"><a href="#1-3-变址寄存器-SI-DI" class="headerlink" title="1.3 变址寄存器 SI, DI"></a>1.3 变址寄存器 SI, DI</h3><p>寄存器<code>SI</code>被称为源变址寄存器,<br>寄存器<code>DI</code>被称为目的变址寄存器</p>
<h3 id="1-4-AMD寄存器和Plan-9"><a href="#1-4-AMD寄存器和Plan-9" class="headerlink" title="1.4 AMD寄存器和Plan 9"></a>1.4 AMD寄存器和Plan 9</h3><p>AMD结构有16个通用寄存器, 以及许多其他寄存器. 具体参见<a href="https://docs.oracle.com/cd/E19205-01/821-2506/gituv/index.html" target="_blank" rel="noopener">AMD64 寄存器信息</a><br>下面是AMD64位和Plan 9寄存器的对应关系:</p>
<table>
<thead>
<tr>
<th>amd</th>
<th>plan 9</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rax</td>
<td>ax</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>rbx</td>
<td>bx</td>
<td>被调用方保存</td>
</tr>
<tr>
<td>rcx</td>
<td>cx</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>rdx</td>
<td>dx</td>
<td>为函数调用传递参数</td>
</tr>
<tr>
<td>rdi</td>
<td>di</td>
<td>为函数调用传递参数  </td>
</tr>
<tr>
<td>rsi</td>
<td>si</td>
<td>为函数调用传递参数</td>
</tr>
<tr>
<td>rbp</td>
<td>bp</td>
<td>栈管理/帧指针</td>
</tr>
<tr>
<td>rsp</td>
<td>sp</td>
<td>栈管理/栈指针</td>
</tr>
<tr>
<td>r8</td>
<td>r8</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>r9</td>
<td>r9</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>r10</td>
<td>r10</td>
<td>临时</td>
</tr>
<tr>
<td>r11</td>
<td>r11</td>
<td>临时</td>
</tr>
<tr>
<td>r12</td>
<td>r12</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r13</td>
<td>r13</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r14</td>
<td>r14</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r15</td>
<td>r15</td>
<td>被调用方保存 </td>
</tr>
</tbody>
</table>
<h3 id="1-5-伪寄存器"><a href="#1-5-伪寄存器" class="headerlink" title="1.5 伪寄存器"></a>1.5 伪寄存器</h3><p>Go 的汇编还引入了 4 个伪寄存器，援引官方文档的描述:</p>
<ul>
<li>FP: 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP).</li>
<li>PC: 实际上就是在体系结构的知识中常见的pc寄存器，在x86平台下对应ip寄存器，amd64上则是rip。除了个别跳转 之外，手写代码与PC寄存器打交道的情况较少.</li>
<li>SB: 全局静态基指针，一般用来声明函数或全局变量.</li>
<li>SP: plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0). 与硬件寄存器不同, 手写汇编代码时，如果是 symbol+offset(SP) 形式, 则是伪寄存器, offset(SP) 则表示硬件寄存器<code>SP</code></li>
</ul>
<p>注意: 上述伪寄存器SP和硬件寄存器SP的区分仅应用于代码编写, 对于编译和反编译的结果中的SP, 都是硬件寄存器. </p>
<h2 id="二-变量声明"><a href="#二-变量声明" class="headerlink" title="二. 变量声明"></a>二. 变量声明</h2><p>在汇编里所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。</p>
<p>使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA    symbol+offset(SB)/width, value</span><br></pre></td></tr></table></figure>
<p>使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。<br>GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATA age+0x00(SB)/4, $18  // forever 18</span><br><span class="line">GLOBL age(SB), RODATA, $4</span><br><span class="line"></span><br><span class="line">DATA pi+0(SB)/8, $3.1415926</span><br><span class="line">GLOBL pi(SB), RODATA, $8</span><br><span class="line"></span><br><span class="line">DATA birthYear+0(SB)/4, $1988</span><br><span class="line">GLOBL birthYear(SB), RODATA, $4</span><br></pre></td></tr></table></figure>
<p>正如之前所说，所有符号在声明时，其 offset 一般都是 0。</p>
<p>有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATA bio&lt;&gt;+0(SB)/8, $&quot;oh yes i&quot;</span><br><span class="line">DATA bio&lt;&gt;+8(SB)/8, $&quot;am here &quot;</span><br><span class="line">GLOBL bio&lt;&gt;(SB), RODATA, $16</span><br></pre></td></tr></table></figure>
<p><strong>关于<code>&lt;&gt;</code>, 这个标记跟在符号名后面, 表明该全局变量只在当前文件中使用. </strong></p>
<h2 id="三-函数声明"><a href="#三-函数声明" class="headerlink" title="三. 函数声明"></a>三. 函数声明</h2><p><img src="http://ttc-tal.oss-cn-beijing.aliyuncs.com/1603672041/image.png" alt="image.png"></p>
<blockquote>
<p>$0表示该函数栈大小为0byte，计算栈大小时，需要考虑局部变量和本函数内调用其他函数时，需要传参的空间，不含函数返回地址和CALLER BP。 $16表示该函数入参和返回值一共有16byte。当有NOSPLIT标识时，可以不写输入参数、返回值占用的大小（这时候会强行插入CALLER BP）。</p>
</blockquote>
<h3 id="3-1-argsize-计算规则"><a href="#3-1-argsize-计算规则" class="headerlink" title="3.1 argsize 计算规则"></a>3.1 argsize 计算规则</h3><p>argsize 的计算方法是，参数大小求和+返回值大小求和，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。</p>
<p>不过真实世界永远没有我们假设的这么美好，函数参数往往混合了多种类型，还需要考虑内存对齐问题。</p>
<p>如果不确定自己的函数签名需要多大的 argsize，可以通过简单实现一个相同签名的空函数，然后 go tool objdump 来逆向查找应该分配多少空间。</p>
<h3 id="3-2-framesize-计算规则"><a href="#3-2-framesize-计算规则" class="headerlink" title="3.2 framesize 计算规则"></a>3.2 framesize 计算规则</h3><p>函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：</p>
<ol>
<li>局部变量，及其每个变量的 size。</li>
<li>在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。</li>
<li>原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会死。<br>在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。</li>
</ol>
<h3 id="3-3-一些示例"><a href="#3-3-一些示例" class="headerlink" title="3.3 一些示例"></a>3.3 一些示例</h3><p>math.go:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">10</span>, <span class="number">11</span>))</span><br><span class="line">    fmt.Println(sub(<span class="number">99</span>, <span class="number">15</span>))</span><br><span class="line">    fmt.Println(mul(<span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>math.s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot; // 因为我们声明函数用到了 NOSPLIT 这样的 flag，所以需要将 textflag.h 包含进来</span><br><span class="line"></span><br><span class="line">// func add(a, b int) int</span><br><span class="line">TEXT ·add(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ a+0(FP), AX // 参数 a</span><br><span class="line">    MOVQ b+8(FP), BX // 参数 b</span><br><span class="line">    ADDQ BX, AX    // AX += BX</span><br><span class="line">    MOVQ AX, ret+16(FP) // 返回</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">// func sub(a, b int) int</span><br><span class="line">TEXT ·sub(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ a+0(FP), AX</span><br><span class="line">    MOVQ b+8(FP), BX</span><br><span class="line">    SUBQ BX, AX    // AX -= BX</span><br><span class="line">    MOVQ AX, ret+16(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">// func mul(a, b int) int</span><br><span class="line">TEXT ·mul(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ  a+0(FP), AX</span><br><span class="line">    MOVQ  b+8(FP), BX</span><br><span class="line">    IMULQ BX, AX    // AX *= BX</span><br><span class="line">    MOVQ  AX, ret+16(FP)</span><br><span class="line">    RET</span><br><span class="line">    // 最后一行的空行是必须的，否则可能报 unexpected EOF</span><br></pre></td></tr></table></figure></p>
<h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEA(Q)</td>
<td>Load effective address——取有效地址，也就是取偏移地址</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xargin.com/plan9-assembly/" target="_blank" rel="noopener">plan9 汇编入门</a><br><a href="https://zhuanlan.zhihu.com/p/56750445" target="_blank" rel="noopener">深入理解plan9汇编&amp;实践</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/Gin中HTTP请求的链路追踪/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/13/Gin中HTTP请求的链路追踪/" class="post-title-link" itemprop="http://yoursite.com/index.html">Gin中HTTP请求的链路追踪</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-13 13:54:39" itemprop="dateCreated datePublished" datetime="2020-09-13T13:54:39+08:00">2020-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-17 08:58:48" itemprop="dateModified" datetime="2020-09-17T08:58:48+08:00">2020-09-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一-监听"><a href="#一-监听" class="headerlink" title="一. 监听"></a>一. 监听</h1><p>Gin的自定义监听逻辑比较简单, 在Golang标准HTTP库上层基本没有进行什么封装, 直接调用<code>http.ListenAndServe</code>进行了监听.<br>对应的源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">	&#125;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">		addr = <span class="string">":http"</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>http.ListenAndServe</code>主要进行以下工作</p>
<ol>
<li>生成监听器(Listen)<ul>
<li>解析监听地址&amp;端口号</li>
<li>获取文件描述符</li>
</ul>
</li>
<li>接受请求(Serve)</li>
</ol>
<h2 id="1-1-生成监听器-Listen"><a href="#1-1-生成监听器-Listen" class="headerlink" title="1.1 生成监听器(Listen)"></a>1.1 生成监听器(Listen)</h2><blockquote>
<p>关键代码: net/sock_posix.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket returns a network file descriptor that is ready for</span></span><br><span class="line"><span class="comment">// asynchronous I/O using the network poller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">    s, err := sysSocket(family, sotype, proto)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        poll.CloseFunc(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        poll.CloseFunc(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> sotype &#123;</span><br><span class="line">        <span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line">            <span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != <span class="literal">nil</span> &#123; <span class="comment">// 流监听器</span></span><br><span class="line">                fd.Close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line">            <span class="keyword">if</span> err := fd.listenDatagram(laddr, ctrlFn); err != <span class="literal">nil</span> &#123; <span class="comment">// 数据报监听器</span></span><br><span class="line">                fd.Close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fd.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在该函数的第一部分, 进行了系统调用, 创建了一个socket(关于创建套接字等套接字基础知识, 参见<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-87164/index.html" target="_blank" rel="noopener">套接字基础知识</a>), 此时的参数分别为: </p>
<ul>
<li>family: AF_INET6 Internet IPv6 和 IPv4 系列</li>
<li>sotype: syscall.SOCK_STREAM 可靠面向链接字节流-TCP</li>
<li>proto: 缺省0. </li>
</ul>
</blockquote>
<blockquote>
<p>该函数的第二部分, 对套接字设置了默认选项, 注意此时ipv6only=false. (关于套接字选项的相关知识, 参见<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-49/index.html" target="_blank" rel="noopener">套接字选项</a>)</p>
</blockquote>
<blockquote>
<p>接着创建了一个流监听器, 点开<code>listenDatagram</code>, 可以发现, 在函数内部, 进行了<code>syscall.Bind</code>的系统调用来绑定<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-6/index.html" target="_blank" rel="noopener">本地地址</a>, 调用<code>syscall.Listen</code>来设置监听器允许积压量.<br>通过<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-8/index.html" target="_blank" rel="noopener">建立连接</a>的文档——<code>要接收客户机的连接，服务器必须在绑定其套接字之后执行两个步骤。第一步是说明可以排队多少连接请求。第二步接受连接。</code><br>我们可以发现一个疑问, 在socket函数中, 仅仅进行了第一步操作, 也就是调用<code>syscall.Listen</code>来说明可以排队多少连接请求, 但并没有调用<code>syscall.Accept</code>来接受连接. 很简单, 接受连接的系统调用在下一部分: <code>接收请求</code>.</p>
</blockquote>
<blockquote>
<p>那么该函数的最后一部分, fd.dial主要做了什么工作呢? 实际上socket函数不仅用于服务端监听, 也用于客户端主动建立连接. 当服务端进行监听时, 走fd.listenxxxxx的逻辑, 而接着就直接退出该函数. 当客户端监听时, 直接进入fd.dial的逻辑, 进入该函数, 也可以看到, 内部进行了<code>syscall.Connect</code>的系统调用. </p>
</blockquote>
<h2 id="1-2-接受请求-Serve"><a href="#1-2-接受请求-Serve" class="headerlink" title="1.2 接受请求(Serve)"></a>1.2 接受请求(Serve)</h2><p>首先来看一看注释</p>
<pre><code>// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
// 
// Serve通过监听器l来接收进来的请求, 并为每一个请求创建一个协程. 该协程读取请求, 然后调用srv.Handler进行响应
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	baseCtx := context.Background()</span><br><span class="line">	<span class="keyword">if</span> srv.BaseContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		baseCtx = srv.BaseContext(origListener)</span><br><span class="line">		<span class="keyword">if</span> baseCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"BaseContext returned a nil context"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rw, e := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span> e</span><br><span class="line">		&#125;</span><br><span class="line">		connCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> &#123;</span><br><span class="line">			connCtx = cc(connCtx, rw)</span><br><span class="line">			<span class="keyword">if</span> connCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"ConnContext returned nil"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		c := srv.newConn(rw)</span><br><span class="line">		c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">		<span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到, 在这个函数中, 通过循环去不断的接受连接, 在更底层的地方, <code>l.Accept()</code>也进行了建立连接(<code>syscall.Accept</code>)的系统调用, 并将socket设置为非阻塞型IO, 返回的rw为一个TCP连接<code>TCPConn</code>, 接着新启动一个协程来处理该链接, 然后开始等待下一次<code>新连接</code>的到来. 接着看一下Golang如何处理一个链接</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve a new connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">			c.<span class="built_in">close</span>()</span><br><span class="line">			c.setState(c.rwc, StateClosed)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tls 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">	ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">	c.cancelCtx = cancelCtx</span><br><span class="line">	<span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">	c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">	c.bufr = newBufioReader(c.r)</span><br><span class="line">	c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		w, err := c.readRequest(ctx)</span><br><span class="line">		<span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">			<span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">			c.setState(c.rwc, StateActive)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Expect 100 Continue support</span></span><br><span class="line">		req := w.req</span><br><span class="line">		<span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">			<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">				req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			w.sendExpectationFailed()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			w.conn.r.startBackgroundRead()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">		w.cancelCtx()</span><br><span class="line">		<span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w.finishRequest()</span><br><span class="line">		<span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">			<span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">				c.closeWriteAndWait()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.setState(c.rwc, StateIdle)</span><br><span class="line">		c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">			<span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这段代码中, 有循环读取链接的逻辑. 一开始还有些疑问, Golang不是每次请求都会有一个协程处理吗? 后来查了查, 发现是HTTP的长连接. 确切的说, 并不是每次请求都有一个新的协程去处理, 而是每次新的链接都有一个新的协程处理. 而对于HTTP长连接来说, 多次请求由同一个协程去处理. 然后就有了一次迷糊的过程: </p>
</blockquote>
<h3 id="1-2-1-一次犯迷糊的验证过程"><a href="#1-2-1-一次犯迷糊的验证过程" class="headerlink" title="1.2.1 一次犯迷糊的验证过程"></a>1.2.1 一次犯迷糊的验证过程</h3><blockquote>
<p><img src="/2020/09/13/Gin中HTTP请求的链路追踪/1.png" alt="image.png"><br>因为是HTTP长连接, 所以就想验证下, 然后我用了Postman来请求, 用Goland来打断点debug, 发现每次处理完请求, 都会阻塞在1817行的readRequest那里, 此时相当于等待该链接的下一次请求.<br>后来我换了curl来请求, 然后发现处理完这一次请求之后, 依旧是1817行但是没有阻塞, 返回了EOF的err, </p>
</blockquote>
<h1 id="请求链路"><a href="#请求链路" class="headerlink" title="请求链路"></a>请求链路</h1><h1 id="响应链路"><a href="#响应链路" class="headerlink" title="响应链路"></a>响应链路</h1>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/Golang并发模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/07/Golang并发模型/" class="post-title-link" itemprop="http://yoursite.com/index.html">Golang并发模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-07 22:51:45" itemprop="dateCreated datePublished" datetime="2020-09-07T22:51:45+08:00">2020-09-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-10-27 09:22:52" itemprop="dateModified" datetime="2020-10-27T09:22:52+08:00">2020-10-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<h2 id="一-Channel底层原理"><a href="#一-Channel底层原理" class="headerlink" title="一. Channel底层原理"></a>一. Channel底层原理</h2><h2 id="二-Golang的GPM模型"><a href="#二-Golang的GPM模型" class="headerlink" title="二. Golang的GPM模型"></a>二. Golang的GPM模型</h2><ol>
<li>G: goroutine, </li>
<li>M: 内核线程</li>
<li>P: 代表一个虚拟的处理器(Processor), 它维护一个Runnable的<code>g</code>队列, M需要获得P才能运行G</li>
</ol>
<h3 id="2-1-为什么需要P"><a href="#2-1-为什么需要P" class="headerlink" title="2.1 为什么需要P"></a>2.1 为什么需要P</h3><p>在Go的早期版本, 并没有P这个结构, M需要从一个全局的队列中获得可运行的goroutine, 因此需要一个全局的锁. 当并发量大的时候, 锁就成了瓶颈. 那么为什么不直接将runqueue放入M中?</p>
<blockquote>
<p>You might wonder now, why have contexts at all? Can’t we just put the runqueues on the threads and get rid of contexts? Not really. The reason we have contexts is so that we can hand them off to other threads if the running thread needs to block for some reason.<br>An example of when we need to block, is when we call into a syscall. Since a thread cannot both be executing code and be blocked on a syscall, we need to hand off the context so it can keep scheduling.</p>
</blockquote>
<p>即: 当一个线程被阻塞, 可以将该线程等待的可运行的G转移到其他空闲的M上面<br>另外, Go scheduler 会启动一个后台线程 sysmon，用来检测长时间（超过 10 ms）运行的 goroutine，将其调度到 global runqueues. 这是一个全局的 runqueue，优先级比较低.</p>
<h2 id="last-其他概念"><a href="#last-其他概念" class="headerlink" title="last. 其他概念"></a>last. 其他概念</h2><ol>
<li>超线程: 多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件. </li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/基于FFmpeg的视频水印处理方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/13/基于FFmpeg的视频水印处理方案/" class="post-title-link" itemprop="http://yoursite.com/index.html">基于FFmpeg的视频水印处理方案</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-13 16:13:04 / 修改时间：20:41:48" itemprop="dateCreated datePublished" datetime="2020-06-13T16:13:04+08:00">2020-06-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/视频处理/" itemprop="url" rel="index"><span itemprop="name">视频处理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h2><blockquote>
<p>因政策需要, 五月底收到了一个应急视频水印的需求, 需要对下游生产出来的视频在转码之前进行加水印的处理, 来对视频的<strong>不同片段</strong>进行标记</p>
</blockquote>
<h2 id="二-所需工具"><a href="#二-所需工具" class="headerlink" title="二. 所需工具"></a>二. 所需工具</h2><h3 id="1-FFmpeg"><a href="#1-FFmpeg" class="headerlink" title="1. FFmpeg"></a>1. FFmpeg</h3><blockquote>
<p>FFmpeg我们使用的是<a href="https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz" target="_blank" rel="noopener">ffmpeg v4.2.3-static</a>, 新版本的FFmpeg自带加水印功能, 老版本的可能需要自己编译</p>
</blockquote>
<h3 id="2-Linux字体支持"><a href="#2-Linux字体支持" class="headerlink" title="2. Linux字体支持"></a>2. Linux字体支持</h3><ol>
<li>安装fontconfig <code>yum install fontconfig</code>,</li>
<li>将字体文件放入<code>/usr/share/fonts/chinese</code>目录中</li>
<li>执行<code>fc-list :lang=zh</code>就可以看到安装好的字体文件</li>
</ol>
<h3 id="3-ass-srt-字幕文件"><a href="#3-ass-srt-字幕文件" class="headerlink" title="3. ass(srt)字幕文件"></a>3. ass(srt)字幕文件</h3><h2 id="三-FFmpeg加水印解决方案"><a href="#三-FFmpeg加水印解决方案" class="headerlink" title="三. FFmpeg加水印解决方案"></a>三. FFmpeg加水印解决方案</h2><h3 id="1-加图片水印"><a href="#1-加图片水印" class="headerlink" title="1. 加图片水印"></a>1. 加图片水印</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i origin.mp4 -i watermark.png -filter_complex <span class="string">"overlay=x=main_w-overlay_w:y=main_h-overlay_h"</span> pic_watermark.mp4</span><br></pre></td></tr></table></figure>
<p>水印的位置由如下六个参数来界定.<br>图片水印的优点是水印的格式(字体,颜色,透明度等)可以由UI老师提前生成, 不用执行命令时去控制<br>但是这种水印方式加出来都是整个视频都加上了水印, 如果想要控制某个时间区间去加水印, 不太好控制. 这样也就无法满足本次需求, pass. </p>
<ul>
<li>main_h为输入视频的高度, </li>
<li>main_w为输入视频的宽度, </li>
<li>overlay_h为传入图片的高度, </li>
<li>overlay_w为传入图片的宽度,</li>
<li>x为水印左边界与视频左边界的距离</li>
<li>y为水印上边界与视频上边界的距离</li>
</ul>
<p>加完水印的效果如下图<br><img src="/2020/06/13/基于FFmpeg的视频水印处理方案/pic_watermark.png" alt="image.png"></p>
<h3 id="2-加字幕水印-srt"><a href="#2-加字幕水印-srt" class="headerlink" title="2. 加字幕水印[srt]"></a>2. 加字幕水印[srt]</h3><blockquote>
<p>图片水印无法满足需求, 我们再寻找其他解决方案的时候发现<strong>给视频多个时间区间加水印</strong>与<strong>电影字幕</strong>比较类似, 于是开始寻找给视频加字幕的解决方案. </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i origin.mp4 -vf subtitles=watermark.srt srt_watermark.mp4</span><br></pre></td></tr></table></figure>
<p>字幕内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">00:00:16,266 --&gt; 00:01:00,359</span><br><span class="line">FFMPEG</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">00:01:16,266 --&gt; 00:10:25,359</span><br><span class="line">FFMPEG</span><br></pre></td></tr></table></figure></p>
<p>加出来的效果如下图, 这种方式可以解决按时间区间加水印的需求, 但是无法指定字幕格式, 无法指定字幕位置, 就是单纯的电影字幕(至少我没找到🤦‍♂️). 这种方式也无法满足需求, pass.<br><img src="/2020/06/13/基于FFmpeg的视频水印处理方案/srt.png" alt="image.png"></p>
<h3 id="3-加字幕水印-ass"><a href="#3-加字幕水印-ass" class="headerlink" title="3. 加字幕水印[ass]"></a>3. 加字幕水印[ass]</h3><p>ass字幕文件加水印可以定制很多个性化的东西, 话不多说, 上命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i origin.mp4 -vf <span class="string">"ass=watermark.ass"</span> ass_watermark.mp4</span><br></pre></td></tr></table></figure>
<p>字幕文件内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Script Info]</span><br><span class="line">Title: YYeTs</span><br><span class="line">Original Script: YYeTs</span><br><span class="line">Original Translation:</span><br><span class="line">Original Timing:</span><br><span class="line">Original Editing:</span><br><span class="line">Script Updated By:</span><br><span class="line">Update Details:</span><br><span class="line">ScriptType: v4.00+</span><br><span class="line">PlayResX: 384</span><br><span class="line">PlayResY: 288</span><br><span class="line">Timer: 100.0000</span><br><span class="line">Synch Point: 0</span><br><span class="line">WrapStyle: 0</span><br><span class="line">ScaledBorderAndShadow: no</span><br><span class="line"></span><br><span class="line">[Aegisub Project Garbage]</span><br><span class="line">Scroll Position: 483</span><br><span class="line">Active Line: 441</span><br><span class="line"></span><br><span class="line">[V4+ Styles]</span><br><span class="line">Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding</span><br><span class="line">Style: Default,HanziPen TC,24,&amp;H00FFFFFF,&amp;H00FFFFFF,&amp;H00FFFFFF,&amp;H00FFFFFF,0,0,0,0,100,100,0,0,1,0,1,3,5,10,10,134</span><br><span class="line"></span><br><span class="line">[Events]</span><br><span class="line">Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text</span><br><span class="line">Dialogue: 0,0:00:00.12,0:10:34.29,Default,NTP,0,0,0,,&#123;\alpha&amp;H72&amp;&#125;大鱼海棠</span><br></pre></td></tr></table></figure></p>
<p>Ass字幕文件比较复杂, 反正我是自己手写不出来, 这是我在网上下载了一个ass文件, 自己改了一些参数的最终样子.<br>其中第一部分<code>[Script Info]</code>和第二部分<code>[Aegisub Project Garbage]</code>的意义这里不关注,<br>第三部分<code>[V4+ Styles]</code>包含了所有样式的定义, <code>Format</code>行与<code>Style</code>行 为键值对, Format为Key, Style为Value, 可以定义多个Style, 根据Style.Name区分.<br>第四部分<code>[Events]</code>中, 依旧是Format为Key, Dialogue为每个时间区间, 字幕的各种参数, 包括起止时间, 样式, 以及文案.<br>其中一些Format.Key的意义如下</p>
<ul>
<li>Name: 样式的名字</li>
<li>Fontname: 字体, 中文字体在Linux可以通过fc-list找到对应的英文名</li>
<li>Fontsize: 字体大小</li>
<li>PrimaryColour: 字幕颜色</li>
<li>BackColour: 字体阴影颜色</li>
<li>Bold: 是否加粗</li>
<li>Italic: 是否斜体</li>
<li>Underline: 是否下划线</li>
<li>StrikeOut: 是否删除线</li>
<li>ScaleX: 修改字体的宽度</li>
<li>ScaleY: 修改字体的高度</li>
<li>Spacing: 字符之间额外的间隙</li>
<li>BorderStyle: 边框的样式。1 为边框 + 阴影，3 为不透明背景。</li>
<li>Outline: 如果 BorderStyle 为 1，它定义了文字边框的像素宽度。</li>
<li>Alignment: 字幕位置: 1,2,3 =&gt; 左下, 中下, 右下, 4,5,6 =&gt; 左中, 中中, 右中, 7,8,9=&gt; 左上, 中上, 右上</li>
<li>MarginL: 到屏幕左边缘的距离</li>
<li>MarginR: 到屏幕右边缘的距离</li>
<li>MarginV: 屏幕垂直距离, 如果是底部字幕, 则是屏幕底部的距离</li>
<li>Encoding: 定义字体的字符集或编码方式=&gt;0 为英文，134 为简体中文，136 为繁体中文</li>
<li>样式覆写代码: 样式直接指定透明度试了很多次都不成功, 只好使用样式覆写代码来满足透明度的需求. {\alpha&amp;H72&amp;}为样式覆写代码, 可以重置样式, alpha指定透明度, 72/256=28% , 大概28%的透明度</li>
</ul>
<p>水印效果如下, 用的Mac自带的<code>翩翩体-简</code>, 右下, 底部10, 右屏幕10<br><img src="/2020/06/13/基于FFmpeg的视频水印处理方案/ass.png" alt="image.png"></p>
<h2 id="四-参考资料"><a href="#四-参考资料" class="headerlink" title="四. 参考资料"></a>四. 参考资料</h2><ol>
<li><a href="https://moejj.com/ffmpeg-add-subtitles-and-watermark/" target="_blank" rel="noopener">ffmpeg同时添加水印和字幕，详细教程</a></li>
<li><a href="https://github.com/weizhenye/ASS/wiki/ASS-%E5%AD%97%E5%B9%95%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">ASS 字幕格式规范</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/26/Golang常见错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/26/Golang常见错误/" class="post-title-link" itemprop="http://yoursite.com/index.html">Golang常见错误</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-26 00:30:51" itemprop="dateCreated datePublished" datetime="2020-05-26T00:30:51+08:00">2020-05-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-29 23:41:22" itemprop="dateModified" datetime="2020-05-29T23:41:22+08:00">2020-05-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-变长interface参数"><a href="#1-变长interface参数" class="headerlink" title="1. 变长interface参数"></a>1. 变长interface参数</h3><p>变长interface传参, 传入的数组如果不加<code>...</code>, 可能会被认为是一个interface, 而不会被认为是一个interface数组. 例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calLen</span><span class="params">(src ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(src), src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(src ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	calLen(src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(src ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	calLen(src...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	calLen(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 [1 2 3]</span></span><br><span class="line"><span class="comment">// 1 [[1 2 3]]</span></span><br><span class="line"><span class="comment">// 3 [1 2 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="2-循环初始化-其实不算常见-算设计的比较差"><a href="#2-循环初始化-其实不算常见-算设计的比较差" class="headerlink" title="2. 循环初始化(其实不算常见, 算设计的比较差)"></a>2. 循环初始化(其实不算常见, 算设计的比较差)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	call <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	a    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myStruct = MyStruct&#123;a: <span class="number">1</span>, call: callFunction&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"...."</span>, myStruct.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将编译期的初始化, 改为运行时的初始化(init函数)即可解决问题:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	call <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	a    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myStruct.call = callFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myStruct = MyStruct&#123;a: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">"...."</span>, myStruct.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myStruct.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/值方法还是引用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/25/值方法还是引用方法/" class="post-title-link" itemprop="http://yoursite.com/index.html">值方法还是引用方法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-25 22:28:53" itemprop="dateCreated datePublished" datetime="2020-05-25T22:28:53+08:00">2020-05-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-26 00:30:54" itemprop="dateModified" datetime="2020-05-26T00:30:54+08:00">2020-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章整理自<strong><a href="https://www.qtmuniao.com/2020/01/06/go-value-pointer-method/" target="_blank" rel="noopener">Muniao’s blog</a></strong>, 纯属自行笔记</p>
<h2 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h2><p>关于两者的区别, 在官方 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">effective go</a> 文档中，对两者区别其实是有精确描述的：</p>
<blockquote>
<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
</blockquote>
<blockquote>
<p>There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically.</p>
</blockquote>
<p>大意如下：</p>
<ol>
<li>值方法（value methods）可以通过指针和值调用，但是指针方法（pointer methods）只能通过指针来调用。</li>
<li>但有一个例外，如果某个值是可寻址的（addressable，或者说左值），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用。</li>
</ol>
<h2 id="2-取舍"><a href="#2-取舍" class="headerlink" title="2. 取舍"></a>2. 取舍</h2><p>在定义 receiver 为值还是指针时，主要有以下几个考虑点：</p>
<ol>
<li><strong>方法是否需要修改 receiver 本身。</strong> 如果需要，那 receiver 必然要是指针了。</li>
<li><strong>效率问题。</strong> 如果 receiver 是值，那在方法调用时一定会产生 struct 拷贝，而大对象拷贝代价很大哦。</li>
<li><strong>一致性。</strong> 对于同一个 struct 的方法，value method 和 pointer method 混杂用肯定是不优雅的啦。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/Redis源码-跳跃表skipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/06/Redis源码-跳跃表skipList/" class="post-title-link" itemprop="http://yoursite.com/index.html">Redis源码-跳跃表skipList</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-06 19:35:17 / 修改时间：19:39:38" itemprop="dateCreated datePublished" datetime="2019-03-06T19:35:17+08:00">2019-03-06</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C语言/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="1-内存分布"><a href="#1-内存分布" class="headerlink" title="1. 内存分布"></a>1. 内存分布</h3><p><img src="/2019/03/06/Redis源码-跳跃表skipList/./skiplist.png" alt="Alt text"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                            <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">double</span> score;                       <span class="comment">// 节点的分数, 据此插入时对节点进行排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>     <span class="comment">// 上一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>             <span class="comment">// 子结构, 单层</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">// 当前层下一个节点</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;             <span class="comment">// 当前层距离下一个节点之间的距离</span></span><br><span class="line">    &#125; level[];                          <span class="comment">// 多个层, 其中, 头节点有64层</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  <span class="comment">// 头尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                 <span class="comment">// 节点个数</span></span><br><span class="line">    <span class="keyword">int</span> level;                            <span class="comment">// 层数最多的节点的层数</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<pre><code>头节点不进行存储
</code></pre><h3 id="2-跳跃表的level"><a href="#2-跳跃表的level" class="headerlink" title="2. 跳跃表的level"></a>2. 跳跃表的level</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0xFFFF = 1111111111111111</span></span><br><span class="line"><span class="comment">     * 0xFFFF * 0.25 = 0011111111111111 </span></span><br><span class="line"><span class="comment">     * 也就是最高两位有某位是1的话, level+1, 概率是1/4</span></span><br><span class="line"><span class="comment">     * level的数学期望是4/3, 满足几何分布</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span> ((random() &amp; <span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>level由以上代码生成, 每次level+1的概率是1/4, 出现3/4的概率停止循环, 此时满足几何分布, 
level值的期望是1/(3/4) = 4 / 3
</code></pre><h3 id="3-跳跃表的查找"><a href="#3-跳跃表的查找" class="headerlink" title="3. 跳跃表的查找"></a>3. 跳跃表的查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">           (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">             sdscmp(x-&gt;level[i].forward-&gt;ele, ele) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    update[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>类似的代码在跳跃表源码中出现很多次, 查找的方式很巧妙.
首先跳跃表的列与列之间是从小到大的, 每一列有相同的score
查找时从高level来进行查找, 超出score大小则进行更低level的查询, 此时会从高层跳跃到低层
level的期望值为4/3. 
</code></pre><h3 id="4-插入跳跃表"><a href="#4-插入跳跃表" class="headerlink" title="4. 插入跳跃表"></a>4. 插入跳跃表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string 'ele'. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update[i]表示 第i层新插入的节点应该插入到在update[i]后面</span></span><br><span class="line"><span class="comment">     * rank代表着update[i]点与head之间的距离总和</span></span><br><span class="line"><span class="comment">     * span代表着当前level下, 当前节点与下一节点之间的距离</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level - <span class="number">1</span>) ? <span class="number">0</span> : rank[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当x-&gt;level[i]有下一个节点, 且下一个节点的值小于当前节点</span></span><br><span class="line"><span class="comment">         * 关于小于:</span></span><br><span class="line"><span class="comment">         * 1. 下一个节点的值小于要插入的节点</span></span><br><span class="line"><span class="comment">         * 2. 下一个节点的值等于要插入的节点, 且下一个节点的字符串字典序小于要插入的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 sdscmp(x-&gt;level[i].forward-&gt;ele, ele) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="comment">// 注意是先加后迭代</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level, score, ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进是多步进, 退是单步退</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/06/Redis源码-跳跃表skipList/./1.png" alt="Alt text"><br><img src="/2019/03/06/Redis源码-跳跃表skipList/./2.png" alt="Alt text"></p>
<pre><code>插入时候首先查询到该插入的位置, 实际上是一列.
然后获取随机的level
进行节点的插入. 更新每一层的span值. 
其中, 对line54, line55行的解释如下:
对比第一张图, 在列4和列5之间添加一个节点, 他的level=5, 插入之后的结果为第二张图, 新插入的数据在第五列
那么在第一章图中, rank[0]=1+1+1+1=4; rank[3]=2+1=3,node[3]-&gt;level[3].span=2
那么插入之后, x-&gt;level[3].span=update[3]-&gt;level[3].span-(rank[0]-rank[3])=2-(2-1)=1
见第二张图. 
update[3]-&gt;level[3].span=(rank[0]-rank[3])+1=2
不知道怎么说的更清楚, 我也看了很久, 解释如此, 自己悟...
</code></pre><h3 id="5-更新某节点"><a href="#5-更新某节点" class="headerlink" title="5. 更新某节点"></a>5. 更新某节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update the score of an elmenent inside the sorted set skiplist.</span></span><br><span class="line"><span class="comment"> * Note that the element must exist and must match 'score'.</span></span><br><span class="line"><span class="comment"> * This function does not update the score in the hash table side, the</span></span><br><span class="line"><span class="comment"> * caller should take care of it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function attempts to just update the node, in case after</span></span><br><span class="line"><span class="comment"> * the score update, the node would be exactly at the same position.</span></span><br><span class="line"><span class="comment"> * Otherwise the skiplist is modified by removing and re-adding a new</span></span><br><span class="line"><span class="comment"> * element, which is more costly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the updated element skiplist node pointer. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we'll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                 sdscmp(x-&gt;level[i].forward-&gt;ele, ele) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele, ele) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the node, after the score update, would be still exactly</span></span><br><span class="line"><span class="comment">     * at the same position, we can just update the score without</span></span><br><span class="line"><span class="comment">     * actually removing and re-inserting the element in the skiplist. */</span></span><br><span class="line">    <span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore)) &#123;</span><br><span class="line">        x-&gt;score = newscore;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl, newscore, x-&gt;ele);</span><br><span class="line">    <span class="comment">/* We reused the old node x-&gt;ele SDS string, free the node now</span></span><br><span class="line"><span class="comment">     * since zslInsert created a new one. */</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>更新节点score时, 因为score更新之后, 为了保证顺序性, 需要对列进行调整, 不如直接删除节点, 
然后在合适位置添加新的列
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/Redis源码-字典dict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/05/Redis源码-字典dict/" class="post-title-link" itemprop="http://yoursite.com/index.html">Redis源码-字典dict</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-05 11:56:29 / 修改时间：15:33:14" itemprop="dateCreated datePublished" datetime="2019-03-05T11:56:29+08:00">2019-03-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C语言/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字典-哈希表"><a href="#字典-哈希表" class="headerlink" title="字典/哈希表"></a>字典/哈希表</h2><h3 id="1-内存布局"><a href="#1-内存布局" class="headerlink" title="1. 内存布局"></a>1. 内存布局</h3><p><img src="/2019/03/05/Redis源码-字典dict/./dict.png" alt="Alt text"></p>
<p><strong>该图新标签页打开看</strong></p>
<h4 id="1-1-dict"><a href="#1-1-dict" class="headerlink" title="1.1 dict"></a>1.1 dict</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;          <span class="comment">// type</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;          <span class="comment">// paivate data</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];            <span class="comment">// hash table</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;          <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<pre><code>其中type指向dictType, 代表着不同类型的词典. 
privdata 私有数据, 但是我暂时没明白是什么意思.
每个词典有两个hash表, 一个用于正常使用, 一个用于rehash
rehashidx对应rehash时原hash表的rehash的下标, 随着rehash的进行, rehashidx移动
iterators对应迭代器
</code></pre><h4 id="1-2-dictht"><a href="#1-2-dictht" class="headerlink" title="1.2 dictht"></a>1.2 dictht</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash table </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<pre><code>每个hash表包含一个数组, 每个数组的元素指向一个链表, hash 的时候, 将key hash成i,
那么该元素就会被添加到ht[0][i]后面.
size指的是hash表中数组元素的个数
sizemask=size-1 , 因为元素的下标是从0~size-1的
used代表已经占用的桶的个数(桶=数组元素, 数组元素可以看成是桶的入口)
</code></pre><h4 id="1-3-dictType"><a href="#1-3-dictType" class="headerlink" title="1.3 dictType"></a>1.3 dictType</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash表的类型, 对于不同的类型, 实现的方法不同 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * this is a pointer named 'keyDup', it point to a function,</span></span><br><span class="line"><span class="comment">     * and that function's return type is void*, parameters are two pointers */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<pre><code>hash表的类型, 
其中`uint64_t (*hashFunction)(const void *key);`类似于这种结构, 代表着: 
hashFunction是一个指针, 指向一个函数, 该函数以uint64_t类型为返回值, 参数是`const void *key`
</code></pre><h4 id="1-4-dictEntry"><a href="#1-4-dictEntry" class="headerlink" title="1.4 dictEntry"></a>1.4 dictEntry</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 表中单个结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;     <span class="comment">//type val(string, struct)</span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64;  <span class="comment">//type unsigned 64</span></span><br><span class="line">        <span class="keyword">int64_t</span> s64;   <span class="comment">//type signed 64</span></span><br><span class="line">        <span class="keyword">double</span> d;      <span class="comment">// type double</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<pre><code>一个hash元素
key = key
v 是union类型, 可以容纳各种类型的值
next如上图
</code></pre><h3 id="2-hash"><a href="#2-hash" class="headerlink" title="2. hash"></a>2. hash</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d -&gt; 字典</span></span><br><span class="line"><span class="comment"> * key -&gt; 键</span></span><br><span class="line"><span class="comment"> * hash -&gt; 被hash的key</span></span><br><span class="line"><span class="comment"> * existing -&gt; 返回存在的entry</span></span><br><span class="line"><span class="comment"> * 如果已经存在, 返回-1 </span></span><br><span class="line"><span class="comment"> * 如果不存在, 返回可以被hash的一个桶的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span> (he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果没有正在被rehash, 那么直接退出, 此时找到了一个可以使用的idx,</span></span><br><span class="line"><span class="comment">         * 如果正在被rehash, 那么到ht[1]中寻找, 找不到的话, 返回一个ht[1]中可以使用的idx,</span></span><br><span class="line"><span class="comment">         * 保证了不会新增的数据不会被hash到ht[0]中</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果key已经存在, 返回NULL, 而且如果existing非空, 它会被填充为已经存在的entry, </span></span><br><span class="line"><span class="comment"> * 如果key被添加, 返回被添加的hash entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d, key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>关于hash , 不同类型调用的是不同的hash方法(见dictType)
字符串类型, 调用的是siphash, 关于这种hash方法, 我也没看懂... 
关于存储, 一个key被hash成int类型的值h,
h&amp;sizemask获得一个可以存储在hashtable中的一个桶的下标.
然后开辟空间, 赋值, 将entry添加到桶的起始位置
</code></pre><h3 id="3-rehash"><a href="#3-rehash" class="headerlink" title="3. rehash"></a>3. rehash</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>当hash表空间进行resize/expand时, 需要rehash, rehash的过程如下: 
1.  将ht[1]指向新开辟的空间
2.  将ht[0]迁移到ht[1]中, 迁移前后, 同一个元素获得的桶的下标可能变化(因为sizemask的变化)
3.  rehash是一桶一桶的迁移的, 伴随着rehashidx的增加, 保证ht[0]中小于rehashidx的桶中无元素
4.  对于rehash过程中新增的元素, 如果ht[0]中已经存在该key, 那么就返回, 如果不存在,
    那么就在ht[1]中新增该key,详情见dictAddRaw和_dictKeyIndex方法
5.  rehash过程发生在对dict进行增删改查时, 每次执行_dictRehashStep一次,
    既保证了rehash过程的进行, 又将耗时比较长的整个rehash过程均分到每次操作中
6.  rehash过程执行完成之后, ht[0]被释放, 然后ht[0]指向ht[1], ht[1]指向空,
    rehashidx被置为零, rehash结束, ht[0]又成为唯一使用中的hash表
</code></pre><h3 id="4-字典的遍历"><a href="#4-字典的遍历" class="headerlink" title="4. 字典的遍历"></a>4. 字典的遍历</h3><p>详情见<a href="https://blog.csdn.net/gqtcgq/article/details/50533336" target="_blank" rel="noopener">Redis源码解析：04字典的遍历dictScan</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Redis源码-动态字符串sds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/Redis源码-动态字符串sds/" class="post-title-link" itemprop="http://yoursite.com/index.html">Redis源码-动态字符串sds</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 18:41:08 / 修改时间：19:21:57" itemprop="dateCreated datePublished" datetime="2019-02-28T18:41:08+08:00">2019-02-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C语言/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="动态字符串sds"><a href="#动态字符串sds" class="headerlink" title="动态字符串sds"></a>动态字符串sds</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="/2019/02/28/Redis源码-动态字符串sds/./sds.png" alt="Alt text"></p>
<h3 id="sds头结构"><a href="#sds头结构" class="headerlink" title="sds头结构"></a>sds头结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;         <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;       <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len;        <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc;      <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;        <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc;      <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;        <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc;      <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>sdshdr是存储sds字符串的信息
其中len为字符串的长度, 
alloc存储的是buf指针分配空间的大小, 
flags表示字符串的类型,5,8,16,32,64 
其中sdshdr5不使用
</code></pre><hr>
<pre><code>__attribute__机制: 
是gnu的一大特色, 可以设置函数属性, 变量属性和类型属性
其位置约束一般放在声明的尾部`;`之前
packed选项代表该结构使用最小的对齐方式
</code></pre><hr>
<pre><code>len为已使用的字符串的长度
alloc是分配的总空间的长度(不包括header)
flags是类型, flags的值为0,1,2,3,4 , 分别对应sdshdr5, sdshdr8, sdshdr16, sdshdr32, sdshdr64
buf是字符串指针起点, 使用空数组, 不占用结构体空间, 代表header末尾, 字符串起点
</code></pre><h3 id="header的部分宏"><a href="#header的部分宏" class="headerlink" title="header的部分宏"></a>header的部分宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T, s) struct sdshdr##T *sh = (void *)((s) - (sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T, s) ((struct sdshdr##T *)((s) - (sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f) &gt;&gt; SDS_TYPE_BITS)</span></span><br><span class="line"><span class="comment">/** 计算长度, f是flag, 只存储三位, 移动之后为0, 因为sdshdr不使用, 直接返回0 **/</span></span><br></pre></td></tr></table></figure>
<p><strong>SDS_HDR_VAR</strong></p>
<pre><code>声明一个sh, 指向s的头起始地址
## 将两个宏参数拼接
比如, 如果调用SDS_HDR_VAR(8,s)
那么调用宏的结果是:  
struct sdshdr8 *sh = (void *)((s) - (sizeof(struct sdshdr8)));
this is amazing!!! 
该宏的作用是计算sds起始地址
</code></pre><hr>
<p><strong>SDS_HDR</strong></p>
<pre><code>直接返回一个sh, 指向s的头起始地址
</code></pre><hr>
<p><strong>SDS_TYPE_5_LEN</strong></p>
<pre><code>计算长度, f是flag, 只存储三位, 移动之后为0, 因为sdshdr5不使用, 直接返回0
</code></pre><h3 id="header的部分函数"><a href="#header的部分函数" class="headerlink" title="header的部分函数"></a>header的部分函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>, s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>, s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>返回s的字符串长度
关于s[-1]:
    1. s指向的是字符串的位置, 在这里就是sdshdr中buf的地址
    2. 结构体中空数组不占用存储空间, 数组指向一个地址, 在这里就是s的起始地址.
    3. 所以s=buf, s[-1]=flag
    4. s[-1]是真的骚操作...
</code></pre><h3 id="sds的函数总结"><a href="#sds的函数总结" class="headerlink" title="sds的函数总结"></a>sds的函数总结</h3><h4 id="开辟"><a href="#开辟" class="headerlink" title="开辟"></a>开辟</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个sds, init为字符串起始地址, initlen为长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>; </span><br><span class="line"><span class="comment">//初始化一个空的sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="comment">//new一个sds, 字符串的值为init</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"><span class="comment">//复制一个sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>;</span><br><span class="line"><span class="comment">//使sds中的free space能容纳addlen长度的字符串. 不够开辟空间, 足够不开辟</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>;</span><br></pre></td></tr></table></figure>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放sds空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="comment">//清除掉末尾的空闲空间, 以免空间占用过多</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="comment">//清除sds中的字符串, 即将string部分变成free space</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="更新-amp-获取header"><a href="#更新-amp-获取header" class="headerlink" title="更新&amp;获取header"></a>更新&amp;获取header</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类型获得结构体大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span></span>; </span><br><span class="line"><span class="comment">//通过字符串长度获得类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span></span>; </span><br><span class="line"><span class="comment">//更新sds中的len字段, 仅仅是更新该字段. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="comment">//获取包括sds头在内的占用空间总量</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsAllocSize</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="comment">//获取获得hdr的起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span> </span>;</span><br><span class="line"><span class="comment">//根据incr(可正可负), 调整len大小. 更新len和结尾'\0'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span> </span>;</span><br><span class="line"><span class="comment">//使得sds中的string增长到len的长度, 多出的部分重置为0, 如果len较小, 不操作</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>;</span><br><span class="line"><span class="comment">//转义拼接</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>;</span><br></pre></td></tr></table></figure>
<h4 id="整型转sds"><a href="#整型转sds" class="headerlink" title="整型转sds"></a>整型转sds</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsull2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>;</span><br></pre></td></tr></table></figure>
<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>;</span><br><span class="line"><span class="comment">// 类似于sdscatprintf, 但是比sdscatprintf快, 功能仅限于上面的类型</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span> </span>;</span><br></pre></td></tr></table></figure>
<h4 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>;</span><br><span class="line"><span class="comment">//释放由sdssplitlen开辟的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>;</span><br><span class="line"><span class="comment">// 将字符串中的form字符替换成to</span></span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span> </span>;</span><br></pre></td></tr></table></figure>
<p><code>`</code></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default.png" alt="flyfish">
            
              <p class="site-author-name" itemprop="name">flyfish</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flyfish</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
